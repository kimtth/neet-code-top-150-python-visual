<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merge K Sorted Lists - Algorithm Visualization</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    </div>

    <div class="container">
        <div class="problem-info">
            <h1><span class="problem-number">#0023</span> Merge K Sorted Lists</h1>
            <p>
                Given an array of <strong>k</strong> sorted linked lists, merge them into one sorted linked list.
                Uses a <strong>min-heap</strong> to efficiently select the smallest element.
            </p>
            <p><strong>Example:</strong> [[1,4,5],[1,3,4],[2,6]] ‚Üí [1,1,2,3,4,4,5,6]</p>
            <p><strong>Time Complexity:</strong> O(N log k) where N is total elements, k is number of lists</p>
            <p><strong>Space Complexity:</strong> O(k) for the heap</p>
            <div class="problem-meta">
                <span class="meta-tag">üîó Linked List</span>
                <span class="meta-tag">üìä Sorting</span>
                <span class="meta-tag">‚è±Ô∏è O(n log n)</span>
            </div>
            <div class="file-ref">
                üìÑ Python: <code>python/0023_merge_k_sorted_lists/0023_merge_k_sorted_lists.py</code>
            </div>

        </div>

        <div class="explanation-panel">
            <h4>üß† How It Works (Layman's Terms)</h4>
            <p>A linked list is like a <strong>chain of train cars</strong>:</p>
            <ul>
                <li><strong>Each node:</strong> Contains data and points to next node</li>
                <li><strong>Traversal:</strong> Follow the chain one node at a time</li>
                <li><strong>Modification:</strong> Redirect links to rearrange</li>
                <li><strong>Two pointers:</strong> Often use slow/fast pointers</li>
            </ul>
        </div>


        <div class="visualization-section">
            <h3>üé¨ Step-by-Step Visualization</h3>
            <div class="controls">
                <button id="stepBtn" class="btn">Step</button>
                <button id="autoBtn" class="btn">Auto Run</button>
                <button id="resetBtn" class="btn btn-secondary">Reset</button>
                <div class="speed-control">
                    <label for="speedSlider">Speed:</label>
                    <input type="range" id="speedSlider" min="1" max="10" value="5">
                </div>
            </div>
            <svg id="visualization" width="900" height="500"></svg>
            <div class="variables-display">
                <div id="varDisplay"></div>
            </div>
            <div class="status-message" id="statusMessage">Press "Step" or "Auto Run" to begin</div>
        </div>

        <div class="code-section">
            <h3>üíª Python Solution</h3>
            <div class="code-block">
                <pre><span class="keyword">def</span> <span class="function">merge_k_lists</span>(self, lists: <span class="class-name">List</span>[ListNode]) -> ListNode:
    dummy = <span class="function">ListNode</span>(<span class="number">0</span>)
    current = dummy
    min_heap = []
    
    <span class="comment"># Add head of each list to heap</span>
    <span class="keyword">for</span> i, head <span class="keyword">in</span> <span class="function">enumerate</span>(lists):
        <span class="keyword">if</span> head:
            heapq.<span class="function">heappush</span>(min_heap, (head.val, i, head))
    
    <span class="comment"># Process heap</span>
    <span class="keyword">while</span> min_heap:
        val, i, node = heapq.<span class="function">heappop</span>(min_heap)
        current.next = node
        current = current.next
        
        <span class="keyword">if</span> node.next:
            heapq.<span class="function">heappush</span>(min_heap, (node.next.val, i, node.next))
    
    <span class="keyword">return</span> dummy.next</pre>
            </div>
        </div>
    </div>

    <script>
        // Data
        const lists = [
            [1, 4, 5],
            [1, 3, 4],
            [2, 6]
        ];
        const colors = ['#667eea', '#764ba2', '#06b6d4'];
        
        // State
        let step = 0;
        let autoRunning = false;
        let autoInterval = null;
        
        // Generate steps
        const steps = [];
        
        function generateSteps() {
            steps.length = 0;
            
            // Initial state
            const pointers = [0, 0, 0];
            const heap = [];
            const result = [];
            
            steps.push({
                type: 'init',
                lists: lists.map(l => [...l]),
                pointers: [...pointers],
                heap: [],
                result: [],
                message: 'Initialize: 3 sorted lists to merge'
            });
            
            // Add initial heads to heap
            for (let i = 0; i < lists.length; i++) {
                if (lists[i].length > 0) {
                    heap.push({ val: lists[i][0], listIdx: i, color: colors[i] });
                }
            }
            heap.sort((a, b) => a.val - b.val);
            
            steps.push({
                type: 'init_heap',
                lists: lists.map(l => [...l]),
                pointers: [...pointers],
                heap: heap.map(h => ({...h})),
                result: [],
                message: `Add head of each list to min-heap: [${heap.map(h => h.val).join(', ')}]`
            });
            
            // Process heap
            while (heap.length > 0) {
                // Pop minimum
                const min = heap.shift();
                
                steps.push({
                    type: 'pop',
                    lists: lists.map(l => [...l]),
                    pointers: [...pointers],
                    heap: heap.map(h => ({...h})),
                    result: [...result],
                    popped: min,
                    message: `Pop min: ${min.val} (from list ${min.listIdx + 1})`
                });
                
                result.push(min);
                pointers[min.listIdx]++;
                
                steps.push({
                    type: 'add_result',
                    lists: lists.map(l => [...l]),
                    pointers: [...pointers],
                    heap: heap.map(h => ({...h})),
                    result: result.map(r => ({...r})),
                    message: `Add ${min.val} to result. Result: [${result.map(r => r.val).join(', ')}]`
                });
                
                // Add next from same list if exists
                const listIdx = min.listIdx;
                const nextIdx = pointers[listIdx];
                if (nextIdx < lists[listIdx].length) {
                    const nextVal = lists[listIdx][nextIdx];
                    heap.push({ val: nextVal, listIdx: listIdx, color: colors[listIdx] });
                    heap.sort((a, b) => a.val - b.val);
                    
                    steps.push({
                        type: 'push',
                        lists: lists.map(l => [...l]),
                        pointers: [...pointers],
                        heap: heap.map(h => ({...h})),
                        result: result.map(r => ({...r})),
                        pushed: { val: nextVal, listIdx: listIdx },
                        message: `Push next from list ${listIdx + 1}: ${nextVal}. Heap: [${heap.map(h => h.val).join(', ')}]`
                    });
                }
            }
            
            steps.push({
                type: 'done',
                lists: lists.map(l => [...l]),
                pointers: [...pointers],
                heap: [],
                result: result.map(r => ({...r})),
                message: `Done! Merged result: [${result.map(r => r.val).join(', ')}]`
            });
        }
        
        // SVG setup
        const svg = d3.select("#visualization");
        const width = 900;
        const height = 500;
        
        function draw(currentStep) {
            svg.selectAll("*").remove();
            
            const data = currentStep || steps[0];
            const nodeWidth = 40;
            const nodeHeight = 35;
            const gap = 55;
            
            // Draw input lists
            svg.append("text")
                .attr("x", 30)
                .attr("y", 30)
                .attr("class", "label")
                .text("Input Lists:");
            
            lists.forEach((list, listIdx) => {
                const y = 50 + listIdx * 60;
                
                svg.append("text")
                    .attr("x", 30)
                    .attr("y", y + 22)
                    .attr("fill", colors[listIdx])
                    .attr("font-weight", "bold")
                    .text(`List ${listIdx + 1}:`);
                
                list.forEach((val, i) => {
                    const x = 100 + i * gap;
                    const isProcessed = data.pointers && data.pointers[listIdx] > i;
                    const isCurrent = data.pointers && data.pointers[listIdx] === i;
                    
                    const group = svg.append("g")
                        .attr("transform", `translate(${x}, ${y})`);
                    
                    group.append("rect")
                        .attr("width", nodeWidth)
                        .attr("height", nodeHeight)
                        .attr("rx", 6)
                        .attr("fill", isProcessed ? '#d1d5db' : colors[listIdx])
                        .attr("stroke", isCurrent ? '#f59e0b' : 'none')
                        .attr("stroke-width", 3)
                        .attr("opacity", isProcessed ? 0.5 : 1);
                    
                    group.append("text")
                        .attr("x", nodeWidth / 2)
                        .attr("y", nodeHeight / 2 + 5)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .attr("font-weight", "bold")
                        .text(val);
                    
                    if (i < list.length - 1) {
                        svg.append("line")
                            .attr("x1", x + nodeWidth)
                            .attr("y1", y + nodeHeight / 2)
                            .attr("x2", x + gap - 5)
                            .attr("y2", y + nodeHeight / 2)
                            .attr("stroke", isProcessed ? '#d1d5db' : colors[listIdx])
                            .attr("stroke-width", 2);
                    }
                });
            });
            
            // Draw min-heap
            svg.append("text")
                .attr("x", 450)
                .attr("y", 30)
                .attr("class", "label")
                .text("Min-Heap:");
            
            const heapX = 450;
            const heapY = 50;
            
            svg.append("rect")
                .attr("x", heapX)
                .attr("y", heapY)
                .attr("width", 200)
                .attr("height", 100)
                .attr("rx", 10)
                .attr("fill", "#f3f4f6")
                .attr("stroke", "#d1d5db")
                .attr("stroke-width", 2);
            
            if (data.heap && data.heap.length > 0) {
                data.heap.forEach((item, i) => {
                    const x = heapX + 20 + i * 45;
                    const y = heapY + 30;
                    
                    svg.append("rect")
                        .attr("x", x)
                        .attr("y", y)
                        .attr("width", 35)
                        .attr("height", 35)
                        .attr("rx", 6)
                        .attr("fill", item.color || '#667eea');
                    
                    svg.append("text")
                        .attr("x", x + 17)
                        .attr("y", y + 23)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .attr("font-weight", "bold")
                        .text(item.val);
                });
                
                // Show min indicator
                svg.append("text")
                    .attr("x", heapX + 37)
                    .attr("y", heapY + 90)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#16a34a")
                    .attr("font-size", "12px")
                    .text("‚Üë min");
            } else {
                svg.append("text")
                    .attr("x", heapX + 100)
                    .attr("y", heapY + 55)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#9ca3af")
                    .text("(empty)");
            }
            
            // Draw popped item
            if (data.popped) {
                svg.append("text")
                    .attr("x", 700)
                    .attr("y", 30)
                    .attr("class", "label")
                    .text("Popped:");
                
                svg.append("rect")
                    .attr("x", 700)
                    .attr("y", 40)
                    .attr("width", 50)
                    .attr("height", 40)
                    .attr("rx", 8)
                    .attr("fill", data.popped.color || '#4ade80')
                    .attr("stroke", "#16a34a")
                    .attr("stroke-width", 3);
                
                svg.append("text")
                    .attr("x", 725)
                    .attr("y", 67)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .attr("font-weight", "bold")
                    .attr("font-size", "18px")
                    .text(data.popped.val);
            }
            
            // Draw result
            svg.append("text")
                .attr("x", 30)
                .attr("y", 280)
                .attr("class", "label")
                .text("Result:");
            
            if (data.result && data.result.length > 0) {
                data.result.forEach((item, i) => {
                    const x = 100 + i * 50;
                    const isNew = i === data.result.length - 1 && data.type === 'add_result';
                    
                    const group = svg.append("g")
                        .attr("transform", `translate(${x}, 260)`);
                    
                    group.append("rect")
                        .attr("width", 40)
                        .attr("height", 35)
                        .attr("rx", 6)
                        .attr("fill", item.color || '#4ade80')
                        .attr("stroke", isNew ? '#f59e0b' : 'none')
                        .attr("stroke-width", 3);
                    
                    group.append("text")
                        .attr("x", 20)
                        .attr("y", 23)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .attr("font-weight", "bold")
                        .text(item.val);
                    
                    if (i < data.result.length - 1) {
                        svg.append("line")
                            .attr("x1", x + 40)
                            .attr("y1", 277)
                            .attr("x2", x + 47)
                            .attr("y2", 277)
                            .attr("stroke", "#4ade80")
                            .attr("stroke-width", 2);
                    }
                });
            } else {
                svg.append("text")
                    .attr("x", 100)
                    .attr("y", 280)
                    .attr("fill", "#9ca3af")
                    .text("(building...)");
            }
            
            // Legend
            svg.append("text")
                .attr("x", 30)
                .attr("y", 350)
                .attr("class", "label")
                .text("Legend:");
            
            colors.forEach((color, i) => {
                svg.append("rect")
                    .attr("x", 100 + i * 100)
                    .attr("y", 335)
                    .attr("width", 20)
                    .attr("height", 20)
                    .attr("fill", color);
                
                svg.append("text")
                    .attr("x", 125 + i * 100)
                    .attr("y", 350)
                    .attr("fill", "#4b5563")
                    .text(`List ${i + 1}`);
            });
            
            // Update status
            document.getElementById("statusMessage").textContent = data.message;
            
            // Update variables
            document.getElementById("varDisplay").innerHTML = `
                <span class="var-item">Heap Size: ${data.heap ? data.heap.length : 0}</span>
                <span class="var-item">Result Size: ${data.result ? data.result.length : 0}</span>
                <span class="var-item">Heap: [${data.heap ? data.heap.map(h => h.val).join(', ') : ''}]</span>
            `;
        }
        
        function doStep() {
            if (step >= steps.length) {
                stopAuto();
                return;
            }
            draw(steps[step]);
            step++;
        }
        
        function stopAuto() {
            autoRunning = false;
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
            }
            document.getElementById("autoBtn").textContent = "Auto Run";
        }
        
        function toggleAuto() {
            if (autoRunning) {
                stopAuto();
            } else {
                autoRunning = true;
                document.getElementById("autoBtn").textContent = "Pause";
                const speed = 11 - document.getElementById("speedSlider").value;
                autoInterval = setInterval(() => {
                    if (step >= steps.length) {
                        stopAuto();
                        return;
                    }
                    doStep();
                }, speed * 200);
            }
        }
        
        function reset() {
            stopAuto();
            step = 0;
            draw(steps[0]);
        }
        
        // Initialize
        generateSteps();
        draw(steps[0]);
        
        // Event listeners
        document.getElementById("stepBtn").addEventListener("click", doStep);
        document.getElementById("autoBtn").addEventListener("click", toggleAuto);
        document.getElementById("resetBtn").addEventListener("click", reset);
    </script>
</body>
</html>
