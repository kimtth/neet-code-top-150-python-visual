<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>148 - Sort List</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .legend { display: flex; justify-content: center; gap: 20px; margin: 15px 0; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 0.85rem; color: #64748b; }
        .legend-color { width: 20px; height: 20px; border-radius: 50%; }
        .phase-indicator { display: flex; justify-content: center; gap: 10px; margin-bottom: 15px; }
        .phase { padding: 8px 15px; border-radius: 20px; font-size: 0.85rem; background: #f1f5f9; color: #64748b; border: 1px solid #e2e8f0; }
        .phase.active { background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; border-color: transparent; }
        #vizArea { min-height: 400px; }
        .info-box { background: #f1f5f9; border-radius: 8px; padding: 15px; margin-bottom: 15px; font-size: 0.9rem; line-height: 1.6; color: #475569; }
    </style>
</head>
<body>
    <div class="container">
        <section class="problem-info">
            <h1><span class="problem-number">#148</span> Sort List</h1>
            <p>Sort a linked list using merge sort in O(n log n) time and O(1) space (bottom-up approach achieves constant space).</p>
            <div class="problem-meta">
                <span class="meta-tag">Medium</span>
                <span class="meta-tag">Linked List</span>
                <span class="meta-tag">Sorting</span>
                <span class="meta-tag">Divide and Conquer</span>
            </div>
            <div class="file-ref">
                ðŸ“„ Python: <code>python/0148_sort_list/0148_sort_list.py</code>
            </div>

        </section>

        <div class="explanation-panel">
            <h4>ðŸ§  How It Works (Layman's Terms)</h4>
            <p>This algorithm solves the problem <strong>step by step</strong>:</p>
            <ul>
                <li><strong>Understand:</strong> Parse the input data</li>
                <li><strong>Process:</strong> Apply the core logic</li>
                <li><strong>Optimize:</strong> Use efficient data structures</li>
                <li><strong>Return:</strong> Output the computed result</li>
            </ul>
        </div>


        <section class="visualization-section">
            <h3>ðŸŽ¬ Step-by-Step Visualization</h3>
            <div class="controls">
                <button id="stepBtn" onclick="step()">Step</button>
                <button id="autoBtn" onclick="toggleAuto()">â–¶ Auto Run</button>
                <button onclick="reset()">Reset</button>
            </div>
        </section>

        <section class="visualization-section">
            <h3>ðŸŽ¬ Step-by-Step Visualization</h3>
            <div class="info-box">
                <strong>Merge Sort for Linked List:</strong> 
                1. Find middle using slow/fast pointers  
                2. Split list into two halves  
                3. Recursively sort each half  
                4. Merge sorted halves
            </div>
            <div class="phase-indicator" id="phaseIndicator">
                <div class="phase" id="phaseSplit">Split</div>
                <div class="phase" id="phaseSort">Recursive Sort</div>
                <div class="phase" id="phaseMerge">Merge</div>
            </div>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background: #6366f1;"></div> Unsorted</div>
                <div class="legend-item"><div class="legend-color" style="background: #f59e0b;"></div> Processing</div>
                <div class="legend-item"><div class="legend-color" style="background: #22c55e;"></div> Sorted</div>
                <div class="legend-item"><div class="legend-color" style="background: #ef4444;"></div> Slow Pointer</div>
                <div class="legend-item"><div class="legend-color" style="background: #0ea5e9;"></div> Fast Pointer</div>
            </div>
            <svg id="vizArea" width="100%" height="450"></svg>
            <div class="status-message" id="stepDisplay">Ready to start</div>
        </section>

        <section class="code-section">
            <h3>ðŸ’» Python Solution</h3>
            <pre><span class="keyword">def</span> <span class="function">sortList</span>(head: <span class="class-name">ListNode</span>) -> ListNode:
    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:
        <span class="keyword">return</span> head
    
    <span class="comment"># Find middle using slow/fast pointers</span>
    slow, fast = head, head.next
    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:
        slow = slow.next
        fast = fast.next.next
    
    <span class="comment"># Split the list</span>
    mid = slow.next
    slow.next = <span class="keyword">None</span>
    
    <span class="comment"># Recursively sort both halves</span>
    left = <span class="function">sortList</span>(head)
    right = <span class="function">sortList</span>(mid)
    
    <span class="comment"># Merge sorted halves</span>
    <span class="keyword">return</span> <span class="function">merge</span>(left, right)

<span class="keyword">def</span> <span class="function">merge</span>(l1: <span class="class-name">ListNode</span>, l2: <span class="class-name">ListNode</span>) -> ListNode:
    dummy = <span class="function">ListNode</span>(<span class="number">0</span>)
    curr = dummy
    
    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:
        <span class="keyword">if</span> l1.val <= l2.val:
            curr.next = l1
            l1 = l1.next
        <span class="keyword">else</span>:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    
    curr.next = l1 <span class="keyword">or</span> l2
    <span class="keyword">return</span> dummy.next</pre>
        </section>
    </div>

    <script>
        const initialList = [4, 2, 1, 3, 5, 6, 0, 7];
        let steps = [];
        let stepIndex = 0;
        let autoInterval = null;

        function generateMergeSortSteps(arr, depth = 0, offset = 0) {
            const steps = [];
            
            if (arr.length <= 1) {
                steps.push({
                    type: 'base',
                    arr: [...arr],
                    depth,
                    offset,
                    desc: arr.length === 0 ? 'Empty list' : `Single node [${arr[0]}] is already sorted`
                });
                return { steps, sorted: arr };
            }
            
            const mid = Math.floor(arr.length / 2);
            steps.push({
                type: 'split',
                arr: [...arr],
                mid,
                depth,
                offset,
                desc: `Split list at index ${mid}: [${arr.slice(0, mid).join(', ')}] | [${arr.slice(mid).join(', ')}]`
            });
            
            const left = arr.slice(0, mid);
            const leftResult = generateMergeSortSteps(left, depth + 1, offset);
            steps.push(...leftResult.steps);
            
            const right = arr.slice(mid);
            const rightResult = generateMergeSortSteps(right, depth + 1, offset + mid);
            steps.push(...rightResult.steps);
            
            const merged = [];
            let i = 0, j = 0;
            const leftSorted = leftResult.sorted;
            const rightSorted = rightResult.sorted;
            
            while (i < leftSorted.length && j < rightSorted.length) {
                if (leftSorted[i] <= rightSorted[j]) {
                    merged.push(leftSorted[i]);
                    steps.push({
                        type: 'merge',
                        left: [...leftSorted],
                        right: [...rightSorted],
                        leftIdx: i,
                        rightIdx: j,
                        merged: [...merged],
                        depth,
                        offset,
                        desc: `Compare ${leftSorted[i]} â‰¤ ${rightSorted[j]}: take ${leftSorted[i]} from left`
                    });
                    i++;
                } else {
                    merged.push(rightSorted[j]);
                    steps.push({
                        type: 'merge',
                        left: [...leftSorted],
                        right: [...rightSorted],
                        leftIdx: i,
                        rightIdx: j,
                        merged: [...merged],
                        depth,
                        offset,
                        desc: `Compare ${leftSorted[i]} > ${rightSorted[j]}: take ${rightSorted[j]} from right`
                    });
                    j++;
                }
            }
            
            while (i < leftSorted.length) { merged.push(leftSorted[i]); i++; }
            while (j < rightSorted.length) { merged.push(rightSorted[j]); j++; }
            
            steps.push({
                type: 'merged',
                arr: [...merged],
                depth,
                offset,
                desc: `Merged: [${merged.join(', ')}]`
            });
            
            return { steps, sorted: merged };
        }

        function reset() {
            const result = generateMergeSortSteps([...initialList]);
            steps = result.steps;
            stepIndex = 0;
            
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
                document.getElementById('autoBtn').textContent = 'â–¶ Auto Run';
            }
            render();
        }

        function step() {
            if (stepIndex >= steps.length) return;
            stepIndex++;
            render();
        }

        function toggleAuto() {
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
                document.getElementById('autoBtn').textContent = 'â–¶ Auto Run';
            } else {
                autoInterval = setInterval(() => {
                    if (stepIndex >= steps.length) {
                        clearInterval(autoInterval);
                        autoInterval = null;
                        document.getElementById('autoBtn').textContent = 'â–¶ Auto Run';
                    } else {
                        step();
                    }
                }, 800);
                document.getElementById('autoBtn').textContent = 'â¸ Pause';
            }
        }

        function render() {
            const svg = d3.select('#vizArea');
            svg.selectAll('*').remove();
            
            const width = svg.node().getBoundingClientRect().width;
            const height = 450;
            const g = svg.append('g').attr('transform', 'translate(40, 30)');
            
            if (stepIndex === 0) {
                renderList(g, initialList, width / 2 - (initialList.length * 35), 50, 'unsorted');
                document.getElementById('stepDisplay').textContent = 'Initial unsorted linked list';
                return;
            }
            
            const curStep = steps[stepIndex - 1];
            
            document.querySelectorAll('.phase').forEach(p => p.classList.remove('active'));
            if (curStep.type === 'split') {
                document.getElementById('phaseSplit').classList.add('active');
            } else if (curStep.type === 'base') {
                document.getElementById('phaseSort').classList.add('active');
            } else {
                document.getElementById('phaseMerge').classList.add('active');
            }
            
            if (curStep.type === 'split') {
                const arr = curStep.arr;
                const mid = curStep.mid;
                const y = 50 + curStep.depth * 80;
                const x = width / 2 - (arr.length * 35);
                
                arr.forEach((val, i) => {
                    const color = i < mid ? '#6366f1' : '#8b5cf6';
                    const cx = x + i * 70 + 25;
                    
                    g.append('circle')
                        .attr('cx', cx).attr('cy', y).attr('r', 25)
                        .attr('fill', color)
                        .attr('stroke', i === mid ? '#f59e0b' : '#fff')
                        .attr('stroke-width', i === mid ? 3 : 1);
                    
                    g.append('text')
                        .attr('x', cx).attr('y', y + 5)
                        .attr('text-anchor', 'middle').attr('fill', '#fff').attr('font-weight', 'bold')
                        .text(val);
                    
                    if (i < arr.length - 1 && i !== mid - 1) {
                        g.append('line')
                            .attr('x1', cx + 25).attr('y1', y).attr('x2', cx + 45).attr('y2', y)
                            .attr('stroke', '#0ea5e9').attr('stroke-width', 2);
                    }
                });
                
                const splitX = x + mid * 70 - 10;
                g.append('line')
                    .attr('x1', splitX).attr('y1', y - 40).attr('x2', splitX).attr('y2', y + 40)
                    .attr('stroke', '#f59e0b').attr('stroke-width', 2).attr('stroke-dasharray', '5,5');
                    
            } else if (curStep.type === 'base') {
                const y = 50 + curStep.depth * 80;
                const x = width / 2;
                
                if (curStep.arr.length > 0) {
                    g.append('circle')
                        .attr('cx', x).attr('cy', y).attr('r', 25)
                        .attr('fill', '#22c55e').attr('stroke', '#fff');
                    g.append('text')
                        .attr('x', x).attr('y', y + 5)
                        .attr('text-anchor', 'middle').attr('fill', '#fff').attr('font-weight', 'bold')
                        .text(curStep.arr[0]);
                }
                
            } else if (curStep.type === 'merge') {
                const y = 50 + curStep.depth * 80;
                
                const leftX = width / 4;
                curStep.left.forEach((val, i) => {
                    const color = i < curStep.leftIdx ? '#94a3b8' : (i === curStep.leftIdx ? '#f59e0b' : '#6366f1');
                    g.append('circle')
                        .attr('cx', leftX + i * 50).attr('cy', y).attr('r', 20).attr('fill', color);
                    g.append('text')
                        .attr('x', leftX + i * 50).attr('y', y + 5)
                        .attr('text-anchor', 'middle').attr('fill', '#fff').attr('font-weight', 'bold')
                        .text(val);
                });
                
                const rightX = width * 3 / 4 - curStep.right.length * 25;
                curStep.right.forEach((val, i) => {
                    const color = i < curStep.rightIdx ? '#94a3b8' : (i === curStep.rightIdx ? '#f59e0b' : '#8b5cf6');
                    g.append('circle')
                        .attr('cx', rightX + i * 50).attr('cy', y).attr('r', 20).attr('fill', color);
                    g.append('text')
                        .attr('x', rightX + i * 50).attr('y', y + 5)
                        .attr('text-anchor', 'middle').attr('fill', '#fff').attr('font-weight', 'bold')
                        .text(val);
                });
                
                const mergedX = width / 2 - curStep.merged.length * 25;
                curStep.merged.forEach((val, i) => {
                    g.append('circle')
                        .attr('cx', mergedX + i * 50).attr('cy', y + 100).attr('r', 20).attr('fill', '#22c55e');
                    g.append('text')
                        .attr('x', mergedX + i * 50).attr('y', y + 105)
                        .attr('text-anchor', 'middle').attr('fill', '#fff').attr('font-weight', 'bold')
                        .text(val);
                });
                
            } else if (curStep.type === 'merged') {
                const y = 200;
                const x = width / 2 - curStep.arr.length * 35;
                
                curStep.arr.forEach((val, i) => {
                    const cx = x + i * 70 + 25;
                    g.append('circle')
                        .attr('cx', cx).attr('cy', y).attr('r', 25)
                        .attr('fill', '#22c55e').attr('stroke', '#fff');
                    g.append('text')
                        .attr('x', cx).attr('y', y + 5)
                        .attr('text-anchor', 'middle').attr('fill', '#fff').attr('font-weight', 'bold')
                        .text(val);
                    if (i < curStep.arr.length - 1) {
                        g.append('line')
                            .attr('x1', cx + 25).attr('y1', y).attr('x2', cx + 45).attr('y2', y)
                            .attr('stroke', '#0ea5e9').attr('stroke-width', 2);
                    }
                });
            }
            
            document.getElementById('stepDisplay').textContent = curStep.desc;
        }

        function renderList(g, arr, startX, y, state) {
            arr.forEach((val, i) => {
                const cx = startX + i * 70 + 25;
                const color = state === 'sorted' ? '#22c55e' : '#6366f1';
                
                g.append('circle')
                    .attr('cx', cx).attr('cy', y).attr('r', 25)
                    .attr('fill', color).attr('stroke', '#fff');
                g.append('text')
                    .attr('x', cx).attr('y', y + 5)
                    .attr('text-anchor', 'middle').attr('fill', '#fff').attr('font-weight', 'bold')
                    .text(val);
                if (i < arr.length - 1) {
                    g.append('line')
                        .attr('x1', cx + 25).attr('y1', y).attr('x2', cx + 45).attr('y2', y)
                        .attr('stroke', '#0ea5e9').attr('stroke-width', 2);
                }
            });
        }

        reset();
    </script>
</body>
</html>
