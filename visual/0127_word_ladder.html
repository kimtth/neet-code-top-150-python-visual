<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Ladder - LeetCode 127</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="problem-info">
            <h1><span class="problem-number">#0127</span> Word Ladder</h1>
            <p><strong>Problem:</strong> Find the shortest transformation sequence from beginWord to endWord, where each step changes exactly one letter.</p>
            <p><strong>Pattern:</strong> BFS - Find shortest path in unweighted graph of word transformations</p>
            <div class="problem-meta">
                <span class="meta-tag">üî§ String</span>
                <span class="meta-tag">üåä BFS</span>
                <span class="meta-tag">‚è±Ô∏è O(n)</span>
            </div>
            <div class="file-ref">
                üìÑ Python: <code>python/0127_word_ladder/0127_word_ladder.py</code>
            </div>

        </div>

        <div class="explanation-panel">
            <h4>üß† How It Works (Layman's Terms)</h4>
            <p>This algorithm solves the problem <strong>step by step</strong>:</p>
            <ul>
                <li><strong>Understand:</strong> Parse the input data</li>
                <li><strong>Process:</strong> Apply the core logic</li>
                <li><strong>Optimize:</strong> Use efficient data structures</li>
                <li><strong>Return:</strong> Output the computed result</li>
            </ul>
        </div>


        <div class="visualization-section">
            <h3>üé¨ Step-by-Step Visualization</h3>

            <div class="visualization">
            <svg id="mainSvg"></svg>
        </div>

        <div class="controls">
            <button id="stepBtn">Step</button>
            <button id="autoBtn">Auto Run</button>
            <button id="resetBtn">Reset</button>
            <div class="speed-control">
                <label for="speed">Speed:</label>
                <input type="range" id="speed" min="100" max="2000" value="800">
            </div>
        </div>

        <div class="status" id="status">Click "Step" to find shortest path</div>

        <div class="variables">
            <div class="var-item">
                <span class="var-label">Begin:</span>
                <span id="beginDisplay">"hit"</span>
            </div>
            <div class="var-item">
                <span class="var-label">End:</span>
                <span id="endDisplay">"cog"</span>
            </div>
            <div class="var-item">
                <span class="var-label">Path Length:</span>
                <span id="lengthDisplay">-</span>
            </div>
        </div>

        </div>

        <div class="code-section">
            <h3>Python Solution</h3>
            <pre><span class="keyword">def</span> <span class="function">ladderLength</span>(beginWord, endWord, wordList):
    <span class="string">"""
    BFS for shortest transformation path.
    Time: O(N * M^2), Space: O(N * M)
    N = words, M = word length
    """</span>
    wordSet = <span class="function">set</span>(wordList)
    <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordSet:
        <span class="keyword">return</span> <span class="number">0</span>
    
    queue = <span class="function">deque</span>([(beginWord, <span class="number">1</span>)])
    visited = {beginWord}
    
    <span class="keyword">while</span> queue:
        word, length = queue.<span class="function">popleft</span>()
        
        <span class="keyword">if</span> word == endWord:
            <span class="keyword">return</span> length
        
        <span class="comment"># Try changing each character</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="function">len</span>(word)):
            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'abcdefghijklmnopqrstuvwxyz'</span>:
                newWord = word[:<span class="class-name">i</span>] + c + word[i+<span class="number">1</span>:]
                <span class="keyword">if</span> newWord <span class="keyword">in</span> wordSet <span class="keyword">and</span> newWord <span class="keyword">not</span> <span class="keyword">in</span> visited:
                    visited.<span class="function">add</span>(newWord)
                    queue.<span class="function">append</span>((newWord, length + <span class="number">1</span>))
    
    <span class="keyword">return</span> <span class="number">0</span></pre>
        </div>
    </div>

    <script>
        const beginWord = "hit";
        const endWord = "cog";
        const wordList = ["hot", "dot", "dog", "lot", "log", "cog"];

        let wordStates = {}; // word -> 'queue' | 'visiting' | 'visited' | 'found'
        let wordLevels = {}; // word -> level
        let queue = [];
        let found = false;
        let pathLength = 0;
        let autoRunning = false;
        let autoTimer = null;

        const width = 750;
        const height = 420;
        const svg = d3.select("#mainSvg")
            .attr("width", width)
            .attr("height", height);

        // Pre-compute word graph
        function canTransform(w1, w2) {
            let diff = 0;
            for (let i = 0; i < w1.length; i++) {
                if (w1[i] !== w2[i]) diff++;
                if (diff > 1) return false;
            }
            return diff === 1;
        }

        function draw() {
            svg.selectAll("*").remove();

            svg.append("text")
                .attr("x", width / 2).attr("y", 25)
                .attr("text-anchor", "middle")
                .attr("font-weight", "bold")
                .text(`Word Ladder: "${beginWord}" ‚Üí "${endWord}"`);

            // Draw word graph
            const allWords = [beginWord, ...wordList];
            const positions = {
                'hit': {x: 100, y: 200},
                'hot': {x: 250, y: 120},
                'dot': {x: 400, y: 80},
                'dog': {x: 550, y: 120},
                'lot': {x: 400, y: 280},
                'log': {x: 550, y: 240},
                'cog': {x: 650, y: 180}
            };

            // Draw edges
            for (let i = 0; i < allWords.length; i++) {
                for (let j = i + 1; j < allWords.length; j++) {
                    if (canTransform(allWords[i], allWords[j])) {
                        const p1 = positions[allWords[i]];
                        const p2 = positions[allWords[j]];
                        if (p1 && p2) {
                            svg.append("line")
                                .attr("x1", p1.x).attr("y1", p1.y)
                                .attr("x2", p2.x).attr("y2", p2.y)
                                .attr("stroke", "#ddd")
                                .attr("stroke-width", 2);
                        }
                    }
                }
            }

            // Draw nodes
            allWords.forEach(word => {
                const pos = positions[word];
                if (!pos) return;

                const state = wordStates[word];
                const level = wordLevels[word];

                let fill = "#e3f2fd", stroke = "#1976d2";
                if (word === beginWord) {
                    fill = "#bbdefb"; stroke = "#1565c0";
                }
                if (word === endWord) {
                    fill = "#f3e5f5"; stroke = "#7b1fa2";
                }
                if (state === 'queue') {
                    fill = "#fff3e0"; stroke = "#ff9800";
                } else if (state === 'visiting') {
                    fill = "#ffeb3b"; stroke = "#f57c00";
                } else if (state === 'visited') {
                    fill = "#e0e0e0"; stroke = "#757575";
                } else if (state === 'found') {
                    fill = "#c8e6c9"; stroke = "#4caf50";
                }

                svg.append("ellipse")
                    .attr("cx", pos.x).attr("cy", pos.y)
                    .attr("rx", 35).attr("ry", 22)
                    .attr("fill", fill).attr("stroke", stroke).attr("stroke-width", 2);

                svg.append("text")
                    .attr("x", pos.x).attr("y", pos.y + 5)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .attr("font-weight", "bold")
                    .text(word);

                // Level label
                if (level !== undefined) {
                    svg.append("circle")
                        .attr("cx", pos.x + 30).attr("cy", pos.y - 18)
                        .attr("r", 12)
                        .attr("fill", "#e8eaf6").attr("stroke", "#3f51b5");
                    svg.append("text")
                        .attr("x", pos.x + 30).attr("y", pos.y - 14)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "11px")
                        .attr("font-weight", "bold")
                        .text(level);
                }
            });

            // Queue visualization
            svg.append("text")
                .attr("x", 50).attr("y", 360)
                .attr("font-weight", "bold")
                .text("Queue:");

            queue.forEach((item, i) => {
                svg.append("rect")
                    .attr("x", 100 + i * 65).attr("y", 345)
                    .attr("width", 60).attr("height", 28)
                    .attr("fill", "#fff3e0").attr("stroke", "#ff9800");
                svg.append("text")
                    .attr("x", 130 + i * 65).attr("y", 364)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "12px")
                    .text(`${item.word}(${item.level})`);
            });

            // Legend
            const legend = [
                {color: "#e3f2fd", label: "Unvisited"},
                {color: "#fff3e0", label: "In queue"},
                {color: "#ffeb3b", label: "Processing"},
                {color: "#e0e0e0", label: "Visited"},
                {color: "#c8e6c9", label: "Found"}
            ];

            legend.forEach((item, i) => {
                svg.append("rect")
                    .attr("x", 10 + i * 100).attr("y", height - 25)
                    .attr("width", 15).attr("height", 15)
                    .attr("fill", item.color)
                    .attr("stroke", "#999");
                svg.append("text")
                    .attr("x", 28 + i * 100).attr("y", height - 13)
                    .attr("font-size", "10px")
                    .text(item.label);
            });

            // Result
            if (found) {
                svg.append("rect")
                    .attr("x", width - 180).attr("y", height - 55)
                    .attr("width", 170).attr("height", 40)
                    .attr("rx", 8)
                    .attr("fill", "#c8e6c9").attr("stroke", "#4caf50");

                svg.append("text")
                    .attr("x", width - 95).attr("y", height - 28)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "16px")
                    .attr("font-weight", "bold")
                    .text(`Path length: ${pathLength}`);
            }
        }

        function step() {
            if (found) {
                document.getElementById("status").textContent = 
                    `Found! Shortest path length = ${pathLength}`;
                draw();
                return false;
            }

            if (queue.length === 0 && Object.keys(wordStates).length === 0) {
                // Initialize
                queue.push({word: beginWord, level: 1});
                wordStates[beginWord] = 'queue';
                wordLevels[beginWord] = 1;
                document.getElementById("status").textContent = 
                    `Starting BFS from "${beginWord}"`;
                draw();
                return true;
            }

            if (queue.length === 0) {
                document.getElementById("status").textContent = 
                    `No path found!`;
                document.getElementById("lengthDisplay").textContent = "0 (no path)";
                draw();
                return false;
            }

            const {word, level} = queue.shift();
            wordStates[word] = 'visiting';

            document.getElementById("status").textContent = 
                `Processing "${word}" at level ${level}`;

            if (word === endWord) {
                found = true;
                pathLength = level;
                wordStates[word] = 'found';
                document.getElementById("lengthDisplay").textContent = pathLength;
                document.getElementById("status").textContent = 
                    `Found "${endWord}"! Path length = ${level}`;
                draw();
                return false;
            }

            // Find neighbors
            const allWords = [beginWord, ...wordList];
            for (const nextWord of allWords) {
                if (!wordStates[nextWord] && canTransform(word, nextWord)) {
                    wordStates[nextWord] = 'queue';
                    wordLevels[nextWord] = level + 1;
                    queue.push({word: nextWord, level: level + 1});
                }
            }

            wordStates[word] = 'visited';
            draw();
            return true;
        }

        function reset() {
            wordStates = {};
            wordLevels = {};
            queue = [];
            found = false;
            pathLength = 0;
            autoRunning = false;
            if (autoTimer) clearInterval(autoTimer);
            
            document.getElementById("lengthDisplay").textContent = "-";
            document.getElementById("status").textContent = 
                'Click "Step" to find shortest path';
            document.getElementById("autoBtn").textContent = "Auto Run";
            
            draw();
        }

        function autoRun() {
            if (autoRunning) {
                autoRunning = false;
                clearInterval(autoTimer);
                document.getElementById("autoBtn").textContent = "Auto Run";
            } else {
                autoRunning = true;
                document.getElementById("autoBtn").textContent = "Pause";
                const speed = 2100 - document.getElementById("speed").value;
                autoTimer = setInterval(() => {
                    if (!step()) {
                        autoRunning = false;
                        clearInterval(autoTimer);
                        document.getElementById("autoBtn").textContent = "Auto Run";
                    }
                }, speed);
            }
        }

        document.getElementById("stepBtn").addEventListener("click", step);
        document.getElementById("autoBtn").addEventListener("click", autoRun);
        document.getElementById("resetBtn").addEventListener("click", reset);

        draw();
    </script>
</body>
</html>
