<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>097 - Interleaving String</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="problem-info">
            <h1><span class="problem-number">#097</span> Interleaving String</h1>
            <p>
                Check if s3 is formed by interleaving s1 and s2. Uses 2D DP where dp[i][j]
                represents whether s3[0:i+j] can be formed by interleaving s1[0:i] and s2[0:j].
            </p>
            <div class="problem-meta">
                <span class="meta-tag">üî§ String</span>
                <span class="meta-tag">üßÆ DP</span>
                <span class="meta-tag">‚è±Ô∏è O(n)</span>
            </div>
            <div class="file-ref">
                üìÑ Python: <code>python/0097_interleaving_string/0097_interleaving_string.py</code>
            </div>

        </div>

        <div class="explanation-panel">
            <h4>üß† How It Works (Layman's Terms)</h4>
            <p>This algorithm solves the problem <strong>step by step</strong>:</p>
            <ul>
                <li><strong>Understand:</strong> Parse the input data</li>
                <li><strong>Process:</strong> Apply the core logic</li>
                <li><strong>Optimize:</strong> Use efficient data structures</li>
                <li><strong>Return:</strong> Output the computed result</li>
            </ul>
        </div>


        <section class="visualization-section">
            <h3>üé¨ Step-by-Step Visualization</h3>
            <div class="controls">
                <button id="autoRunBtn" class="btn">‚ñ∂ Auto Run</button>
                <button id="stepBtn" class="btn btn-success">Step</button>
                <button id="resetBtn" class="btn btn-danger">Reset</button>
            </div>
            <div class="status" id="status">Click Auto Run to check interleaving</div>
            <svg id="visualization"></svg>
        </section>

        <section class="code-section">
            <h3>üíª Python Solution</h3>
            <div class="code-block">
                <pre><span class="keyword">def</span> <span class="function">isInterleave</span>(s1, s2, s3):
    m, n = <span class="function">len</span>(s1), <span class="function">len</span>(s2)
    <span class="keyword">if</span> <span class="function">len</span>(s3) != m + n:
        <span class="keyword">return</span> <span class="keyword">False</span>
    
    dp = [[<span class="keyword">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="function">range</span>(m + <span class="number">1</span>)]
    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span>
    
    <span class="comment"># First row (s1 empty)</span>
    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="function">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):
        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] <span class="keyword">and</span> s2[j-<span class="number">1</span>] == s3[j-<span class="number">1</span>]
    
    <span class="comment"># First column (s2 empty)</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):
        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">and</span> s1[i-<span class="number">1</span>] == s3[i-<span class="number">1</span>]
    
    <span class="comment"># Fill table</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):
        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="function">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):
            curr = s3[i+j-<span class="number">1</span>]
            match_s1 = dp[i-<span class="number">1</span>][j] <span class="keyword">and</span> s1[i-<span class="number">1</span>] == curr
            match_s2 = dp[i][j-<span class="number">1</span>] <span class="keyword">and</span> s2[j-<span class="number">1</span>] == curr
            dp[i][j] = match_s1 <span class="keyword">or</span> match_s2
    
    <span class="keyword">return</span> dp[m][n]</pre>
            </div>
        </section>
    </div>

    <script>
        const width = 900;
        const height = 600;

        const svg = d3.select("#visualization")
            .attr("width", width)
            .attr("height", height);

        const s1 = "aab";
        const s2 = "axy";
        const s3 = "aaxaby";

        const m = s1.length;
        const n = s2.length;

        let dp = [];
        let currentI = 0;
        let currentJ = 0;
        let phase = 0;  // 0: init, 1: first row, 2: first col, 3: fill, 4: done
        let animationTimer = null;

        function reset() {
            dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(null));
            currentI = 0;
            currentJ = 0;
            phase = 0;
            
            if (animationTimer) clearInterval(animationTimer);
            document.getElementById("status").textContent = 
                `Checking if "${s3}" is interleaving of "${s1}" and "${s2}"`;
            render();
        }

        function render() {
            svg.selectAll("*").remove();

            const cellSize = 50;
            const startX = 120;
            const startY = 120;

            // Draw strings
            drawStrings();

            // Draw DP table
            drawDPTable(startX, startY, cellSize);

            // Draw s3 matching
            drawS3Matching();
        }

        function drawStrings() {
            // s1 (vertical)
            svg.append("text")
                .attr("x", 20)
                .attr("y", 30)
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "#1e293b")
                .text(`s1 = "${s1}"`);

            // s2 (horizontal)
            svg.append("text")
                .attr("x", 120)
                .attr("y", 30)
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "#1e293b")
                .text(`s2 = "${s2}"`);

            // s3
            svg.append("text")
                .attr("x", 250)
                .attr("y", 30)
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "#1e293b")
                .text(`s3 = "${s3}"`);
        }

        function drawDPTable(startX, startY, cellSize) {
            // Column headers (s2)
            svg.append("text")
                .attr("x", startX + cellSize / 2)
                .attr("y", startY - 30)
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .attr("fill", "#64748b")
                .text("Œµ");

            for (let j = 0; j < n; j++) {
                svg.append("text")
                    .attr("x", startX + (j + 1) * cellSize + cellSize / 2)
                    .attr("y", startY - 30)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .attr("font-weight", "bold")
                    .attr("fill", "#3b82f6")
                    .text(s2[j]);
            }

            // Row headers (s1)
            svg.append("text")
                .attr("x", startX - 20)
                .attr("y", startY + cellSize / 2 + 5)
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .attr("fill", "#64748b")
                .text("Œµ");

            for (let i = 0; i < m; i++) {
                svg.append("text")
                    .attr("x", startX - 20)
                    .attr("y", startY + (i + 1) * cellSize + cellSize / 2 + 5)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .attr("font-weight", "bold")
                    .attr("fill", "#10b981")
                    .text(s1[i]);
            }

            // Draw cells
            for (let i = 0; i <= m; i++) {
                for (let j = 0; j <= n; j++) {
                    const x = startX + j * cellSize;
                    const y = startY + i * cellSize;
                    const value = dp[i][j];
                    const isCurrent = i === currentI && j === currentJ && phase > 0 && phase < 4;

                    svg.append("rect")
                        .attr("x", x)
                        .attr("y", y)
                        .attr("width", cellSize - 2)
                        .attr("height", cellSize - 2)
                        .attr("rx", 4)
                        .attr("fill", () => {
                            if (isCurrent) return "#fef3c7";
                            if (value === true) return "#d1fae5";
                            if (value === false) return "#fee2e2";
                            return "#f8fafc";
                        })
                        .attr("stroke", () => {
                            if (isCurrent) return "#f59e0b";
                            if (value === true) return "#10b981";
                            if (value === false) return "#ef4444";
                            return "#e2e8f0";
                        })
                        .attr("stroke-width", isCurrent ? 3 : 1);

                    if (value !== null) {
                        svg.append("text")
                            .attr("x", x + cellSize / 2 - 1)
                            .attr("y", y + cellSize / 2 + 5)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "12px")
                            .attr("font-weight", "bold")
                            .attr("fill", value ? "#10b981" : "#ef4444")
                            .text(value ? "T" : "F");
                    }
                }
            }

            // Index labels
            svg.append("text")
                .attr("x", startX - 50)
                .attr("y", startY - 50)
                .attr("font-size", "12px")
                .attr("fill", "#64748b")
                .text("dp[i][j]");
        }

        function drawS3Matching() {
            const startX = 450;
            const startY = 100;

            svg.append("text")
                .attr("x", startX)
                .attr("y", startY - 20)
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "#1e293b")
                .text("Target s3:");

            s3.split('').forEach((ch, idx) => {
                const x = startX + (idx % 6) * 45;
                const y = startY + Math.floor(idx / 6) * 50;
                const matchedUpTo = phase === 4 ? s3.length : currentI + currentJ;
                const isMatched = idx < matchedUpTo && phase > 0;

                svg.append("rect")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("width", 40)
                    .attr("height", 40)
                    .attr("rx", 6)
                    .attr("fill", isMatched ? "#d1fae5" : "#f8fafc")
                    .attr("stroke", isMatched ? "#10b981" : "#94a3b8")
                    .attr("stroke-width", 2);

                svg.append("text")
                    .attr("x", x + 20)
                    .attr("y", y + 27)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "18px")
                    .attr("font-weight", "bold")
                    .attr("fill", "#1e293b")
                    .text(ch);

                svg.append("text")
                    .attr("x", x + 20)
                    .attr("y", y + 55)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "10px")
                    .attr("fill", "#64748b")
                    .text(idx);
            });

            // Explanation
            svg.append("text")
                .attr("x", startX)
                .attr("y", 280)
                .attr("font-size", "12px")
                .attr("fill", "#64748b")
                .text("dp[i][j] = true if s3[0:i+j] can be");

            svg.append("text")
                .attr("x", startX)
                .attr("y", 300)
                .attr("font-size", "12px")
                .attr("fill", "#64748b")
                .text("formed by interleaving s1[0:i] and s2[0:j]");

            svg.append("text")
                .attr("x", startX)
                .attr("y", 340)
                .attr("font-size", "12px")
                .attr("fill", "#10b981")
                .text("‚Ä¢ Match from s1: dp[i-1][j] && s1[i-1] == s3[i+j-1]");

            svg.append("text")
                .attr("x", startX)
                .attr("y", 360)
                .attr("font-size", "12px")
                .attr("fill", "#3b82f6")
                .text("‚Ä¢ Match from s2: dp[i][j-1] && s2[j-1] == s3[i+j-1]");
        }

        function step() {
            if (phase === 4) {
                const result = dp[m][n];
                document.getElementById("status").textContent = 
                    `‚úì Complete! "${s3}" ${result ? "IS" : "is NOT"} an interleaving of "${s1}" and "${s2}"`;
                return;
            }

            if (phase === 0) {
                // Initialize dp[0][0]
                dp[0][0] = true;
                phase = 1;
                currentI = 0;
                currentJ = 1;
                document.getElementById("status").textContent = 
                    "dp[0][0] = true (empty strings match empty s3 prefix)";
            } else if (phase === 1) {
                // Fill first row (s1 empty)
                if (currentJ <= n) {
                    dp[0][currentJ] = dp[0][currentJ - 1] && s2[currentJ - 1] === s3[currentJ - 1];
                    document.getElementById("status").textContent = 
                        `dp[0][${currentJ}]: s2[${currentJ-1}]='${s2[currentJ-1]}' vs s3[${currentJ-1}]='${s3[currentJ-1]}' ‚Üí ${dp[0][currentJ]}`;
                    currentJ++;
                } else {
                    phase = 2;
                    currentI = 1;
                    currentJ = 0;
                }
            } else if (phase === 2) {
                // Fill first column (s2 empty)
                if (currentI <= m) {
                    dp[currentI][0] = dp[currentI - 1][0] && s1[currentI - 1] === s3[currentI - 1];
                    document.getElementById("status").textContent = 
                        `dp[${currentI}][0]: s1[${currentI-1}]='${s1[currentI-1]}' vs s3[${currentI-1}]='${s3[currentI-1]}' ‚Üí ${dp[currentI][0]}`;
                    currentI++;
                } else {
                    phase = 3;
                    currentI = 1;
                    currentJ = 1;
                }
            } else if (phase === 3) {
                // Fill rest of table
                const k = currentI + currentJ - 1;
                const curr = s3[k];
                const matchS1 = dp[currentI - 1][currentJ] && s1[currentI - 1] === curr;
                const matchS2 = dp[currentI][currentJ - 1] && s2[currentJ - 1] === curr;
                dp[currentI][currentJ] = matchS1 || matchS2;

                let explanation = `dp[${currentI}][${currentJ}]: s3[${k}]='${curr}' `;
                if (matchS1) explanation += `‚Üê s1[${currentI-1}]='${s1[currentI-1]}' `;
                if (matchS2) explanation += `‚Üê s2[${currentJ-1}]='${s2[currentJ-1]}' `;
                explanation += `‚Üí ${dp[currentI][currentJ]}`;
                document.getElementById("status").textContent = explanation;

                currentJ++;
                if (currentJ > n) {
                    currentJ = 1;
                    currentI++;
                    if (currentI > m) {
                        phase = 4;
                    }
                }
            }

            render();
        }

        function autoRun() {
            if (animationTimer) {
                clearInterval(animationTimer);
                animationTimer = null;
                document.getElementById("autoRunBtn").textContent = "‚ñ∂ Auto Run";
                return;
            }

            document.getElementById("autoRunBtn").textContent = "‚è∏ Pause";
            animationTimer = setInterval(() => {
                if (phase === 4) {
                    clearInterval(animationTimer);
                    animationTimer = null;
                    document.getElementById("autoRunBtn").textContent = "‚ñ∂ Auto Run";
                    step(); // Final status update
                    return;
                }
                step();
            }, 600);
        }

        document.getElementById("autoRunBtn").addEventListener("click", autoRun);
        document.getElementById("stepBtn").addEventListener("click", step);
        document.getElementById("resetBtn").addEventListener("click", reset);

        reset();
    </script>
</body>
</html>
