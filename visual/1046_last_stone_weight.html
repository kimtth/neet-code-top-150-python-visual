<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Last Stone Weight - LeetCode 1046</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="problem-info">
            <h1><span class="problem-number">#1046</span> Last Stone Weight</h1>
            <p><strong>Problem:</strong> Smash the two heaviest stones together. If unequal, the lighter is destroyed and the heavier loses that weight. Return last stone weight (or 0).</p>
            <p><strong>Pattern:</strong> Max Heap - Always pick two largest stones efficiently</p>
            <div class="problem-meta">
                <span class="meta-tag">üìù Algorithm</span>
                <span class="meta-tag">‚è±Ô∏è O(n)</span>
            </div>
            <div class="file-ref">
                üìÑ Python: <code>python/1046_last_stone_weight/1046_last_stone_weight.py</code>
            </div>

        </div>

        <div class="explanation-panel">
            <h4>üß† How It Works (Layman's Terms)</h4>
            <p>This algorithm solves the problem <strong>step by step</strong>:</p>
            <ul>
                <li><strong>Understand:</strong> Parse the input data</li>
                <li><strong>Process:</strong> Apply the core logic</li>
                <li><strong>Optimize:</strong> Use efficient data structures</li>
                <li><strong>Return:</strong> Output the computed result</li>
            </ul>
        </div>


        <div class="visualization-section">
            <h3>üé¨ Step-by-Step Visualization</h3>

            <div class="visualization">
            <svg id="mainSvg"></svg>
        </div>

        <div class="controls">
            <button id="stepBtn">Step</button>
            <button id="autoBtn">Auto Run</button>
            <button id="resetBtn">Reset</button>
            <div class="speed-control">
                <label for="speed">Speed:</label>
                <input type="range" id="speed" min="100" max="2000" value="800">
            </div>
        </div>

        <div class="status" id="status">Click "Step" to smash stones</div>

        <div class="variables">
            <div class="var-item">
                <span class="var-label">Heap (Max):</span>
                <span id="heapDisplay">[7, 4, 2, 1, 8, 1]</span>
            </div>
            <div class="var-item">
                <span class="var-label">Smashing:</span>
                <span id="smashDisplay">-</span>
            </div>
            <div class="var-item">
                <span class="var-label">Result:</span>
                <span id="resultDisplay">-</span>
            </div>
        </div>

        </div>

        <div class="code-section">
            <h3>üíª Python Solution</h3>
            <div class="code-block">
                <pre><span class="keyword">def</span> <span class="function">lastStoneWeight</span>(stones):
    <span class="string">"""
    Max heap simulation.
    Time: O(n log n), Space: O(n)
    """</span>
    <span class="keyword">import</span> heapq
    
    <span class="comment"># Python has min heap, so negate for max heap</span>
    heap = [-s <span class="keyword">for</span> s <span class="keyword">in</span> stones]
    heapq.<span class="function">heapify</span>(heap)
    
    <span class="keyword">while</span> <span class="function">len</span>(heap) > <span class="number">1</span>:
        first = -heapq.<span class="function">heappop</span>(heap)  <span class="comment"># Largest</span>
        second = -heapq.<span class="function">heappop</span>(heap)  <span class="comment"># Second largest</span>
        
        <span class="keyword">if</span> first != second:
            heapq.<span class="function">heappush</span>(heap, -(first - second))
    
    <span class="keyword">return</span> -heap[<span class="number">0</span>] <span class="keyword">if</span> heap <span class="keyword">else</span> <span class="number">0</span></pre>
            </div>
        </div>
    </div>

    <script>
        const initialStones = [2, 7, 4, 1, 8, 1];
        
        let heap = [];
        let phase = 'init'; // 'init' | 'pick' | 'smash' | 'done'
        let stone1 = null, stone2 = null;
        let smashHistory = [];
        let autoRunning = false;
        let autoTimer = null;

        const width = 700;
        const height = 420;
        const svg = d3.select("#mainSvg")
            .attr("width", width)
            .attr("height", height);

        // Max heap operations
        function heapPush(val) {
            heap.push(val);
            let i = heap.length - 1;
            while (i > 0) {
                const parent = Math.floor((i - 1) / 2);
                if (heap[parent] >= heap[i]) break;
                [heap[parent], heap[i]] = [heap[i], heap[parent]];
                i = parent;
            }
        }

        function heapPop() {
            if (heap.length === 0) return null;
            const max = heap[0];
            heap[0] = heap[heap.length - 1];
            heap.pop();
            
            let i = 0;
            while (true) {
                const left = 2 * i + 1;
                const right = 2 * i + 2;
                let largest = i;
                
                if (left < heap.length && heap[left] > heap[largest]) largest = left;
                if (right < heap.length && heap[right] > heap[largest]) largest = right;
                
                if (largest === i) break;
                [heap[i], heap[largest]] = [heap[largest], heap[i]];
                i = largest;
            }
            
            return max;
        }

        function drawHeap() {
            const startX = width / 2;
            const startY = 80;
            const levelHeight = 55;

            function drawNode(idx, x, y, level) {
                if (idx >= heap.length) return;

                const nodeRadius = 25;
                const spread = 120 / (level + 1);

                // Draw edges first
                const leftIdx = 2 * idx + 1;
                const rightIdx = 2 * idx + 2;
                
                if (leftIdx < heap.length) {
                    svg.append("line")
                        .attr("x1", x).attr("y1", y + nodeRadius)
                        .attr("x2", x - spread).attr("y2", y + levelHeight - nodeRadius)
                        .attr("stroke", "#ddd").attr("stroke-width", 2);
                    drawNode(leftIdx, x - spread, y + levelHeight, level + 1);
                }
                if (rightIdx < heap.length) {
                    svg.append("line")
                        .attr("x1", x).attr("y1", y + nodeRadius)
                        .attr("x2", x + spread).attr("y2", y + levelHeight - nodeRadius)
                        .attr("stroke", "#ddd").attr("stroke-width", 2);
                    drawNode(rightIdx, x + spread, y + levelHeight, level + 1);
                }

                // Draw node
                const isTop = idx === 0;
                const isSecond = idx === 1 || idx === 2;

                svg.append("circle")
                    .attr("cx", x).attr("cy", y).attr("r", nodeRadius)
                    .attr("fill", isTop ? "#bbdefb" : isSecond ? "#e3f2fd" : "#f5f5f5")
                    .attr("stroke", isTop ? "#1565c0" : "#1976d2")
                    .attr("stroke-width", isTop ? 3 : 2);

                svg.append("text")
                    .attr("x", x).attr("y", y + 7)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "18px")
                    .attr("font-weight", "bold")
                    .text(heap[idx]);
            }

            if (heap.length > 0) {
                drawNode(0, startX, startY, 0);
            }
        }

        function draw() {
            svg.selectAll("*").remove();

            svg.append("text")
                .attr("x", width / 2).attr("y", 25)
                .attr("text-anchor", "middle")
                .attr("font-weight", "bold")
                .text("Last Stone Weight (Max Heap)");

            // Draw heap
            svg.append("text")
                .attr("x", 50).attr("y", 55)
                .attr("font-size", "12px")
                .text("Max Heap:");

            if (heap.length > 0) {
                drawHeap();
            } else {
                svg.append("text")
                    .attr("x", width / 2).attr("y", 120)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "18px")
                    .attr("fill", "#999")
                    .text("(empty)");
            }

            // Smash visualization
            if (stone1 !== null && stone2 !== null) {
                svg.append("rect")
                    .attr("x", 50).attr("y", 280)
                    .attr("width", 300).attr("height", 80)
                    .attr("rx", 10)
                    .attr("fill", "#fff3e0").attr("stroke", "#ff9800");

                // Stone 1
                svg.append("circle")
                    .attr("cx", 100).attr("cy", 320)
                    .attr("r", 30)
                    .attr("fill", "#ffeb3b").attr("stroke", "#f57c00");
                svg.append("text")
                    .attr("x", 100).attr("y", 327)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "20px")
                    .attr("font-weight", "bold")
                    .text(stone1);

                // VS
                svg.append("text")
                    .attr("x", 175).attr("y", 327)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "24px")
                    .attr("font-weight", "bold")
                    .attr("fill", "#e53935")
                    .text("üí•");

                // Stone 2
                svg.append("circle")
                    .attr("cx", 250).attr("cy", 320)
                    .attr("r", 30)
                    .attr("fill", "#ffeb3b").attr("stroke", "#f57c00");
                svg.append("text")
                    .attr("x", 250).attr("y", 327)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "20px")
                    .attr("font-weight", "bold")
                    .text(stone2);

                // Result
                if (phase === 'smash') {
                    const diff = stone1 - stone2;
                    svg.append("text")
                        .attr("x", 320).attr("y", 327)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "16px")
                        .text(`= ${diff}`);
                }
            }

            // History
            svg.append("text")
                .attr("x", 400).attr("y", 290)
                .attr("font-weight", "bold")
                .text("History:");

            smashHistory.slice(-4).forEach((entry, i) => {
                svg.append("text")
                    .attr("x", 400).attr("y", 310 + i * 20)
                    .attr("font-size", "12px")
                    .text(entry);
            });

            // Result
            if (phase === 'done') {
                const result = heap.length > 0 ? heap[0] : 0;
                svg.append("rect")
                    .attr("x", width / 2 - 80).attr("y", height - 60)
                    .attr("width", 160).attr("height", 45)
                    .attr("rx", 10)
                    .attr("fill", "#c8e6c9").attr("stroke", "#4caf50");

                svg.append("text")
                    .attr("x", width / 2).attr("y", height - 30)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "18px")
                    .attr("font-weight", "bold")
                    .text(`Result: ${result}`);
            }
        }

        function step() {
            if (phase === 'init') {
                heap = [];
                initialStones.forEach(s => heapPush(s));
                phase = 'pick';
                document.getElementById("heapDisplay").textContent = 
                    `[${heap.join(', ')}]`;
                document.getElementById("status").textContent = 
                    "Built max heap. Ready to smash!";
                draw();
                return true;
            }

            if (phase === 'pick') {
                if (heap.length <= 1) {
                    phase = 'done';
                    const result = heap.length > 0 ? heap[0] : 0;
                    document.getElementById("resultDisplay").textContent = result;
                    document.getElementById("status").textContent = 
                        `Done! Last stone weight: ${result}`;
                    draw();
                    return false;
                }

                stone1 = heapPop();
                stone2 = heapPop();
                document.getElementById("smashDisplay").textContent = 
                    `${stone1} vs ${stone2}`;
                document.getElementById("status").textContent = 
                    `Pick two heaviest: ${stone1} and ${stone2}`;
                phase = 'smash';
                draw();
                return true;
            }

            if (phase === 'smash') {
                const diff = stone1 - stone2;
                smashHistory.push(`${stone1} - ${stone2} = ${diff}`);
                
                if (diff > 0) {
                    heapPush(diff);
                    document.getElementById("status").textContent = 
                        `${stone1} > ${stone2}: ${diff} remains, pushed to heap`;
                } else {
                    document.getElementById("status").textContent = 
                        `${stone1} = ${stone2}: Both destroyed!`;
                }

                document.getElementById("heapDisplay").textContent = 
                    heap.length > 0 ? `[${heap.join(', ')}]` : "[]";
                
                stone1 = null;
                stone2 = null;
                phase = 'pick';
                draw();
                return true;
            }

            return false;
        }

        function reset() {
            heap = [];
            phase = 'init';
            stone1 = null;
            stone2 = null;
            smashHistory = [];
            autoRunning = false;
            if (autoTimer) clearInterval(autoTimer);
            
            document.getElementById("heapDisplay").textContent = 
                `[${initialStones.join(', ')}]`;
            document.getElementById("smashDisplay").textContent = "-";
            document.getElementById("resultDisplay").textContent = "-";
            document.getElementById("status").textContent = 
                'Click "Step" to smash stones';
            document.getElementById("autoBtn").textContent = "Auto Run";
            
            draw();
        }

        function autoRun() {
            if (autoRunning) {
                autoRunning = false;
                clearInterval(autoTimer);
                document.getElementById("autoBtn").textContent = "Auto Run";
            } else {
                autoRunning = true;
                document.getElementById("autoBtn").textContent = "Pause";
                const speed = 2100 - document.getElementById("speed").value;
                autoTimer = setInterval(() => {
                    if (!step()) {
                        autoRunning = false;
                        clearInterval(autoTimer);
                        document.getElementById("autoBtn").textContent = "Auto Run";
                    }
                }, speed);
            }
        }

        document.getElementById("stepBtn").addEventListener("click", step);
        document.getElementById("autoBtn").addEventListener("click", autoRun);
        document.getElementById("resetBtn").addEventListener("click", reset);

        draw();
    </script>
</body>
</html>
