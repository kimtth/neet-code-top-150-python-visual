<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Letter Combinations of Phone Number - LeetCode 17</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="problem-info">
            <h1><span class="problem-number">#0017</span> Letter Combinations of Phone Number</h1>
            <p><strong>Problem:</strong> Given a string of digits 2-9, return all possible letter combinations that the number could represent.</p>
            <p><strong>Pattern:</strong> Backtracking - Build combinations by trying each letter for each digit</p>
            <div class="problem-meta">
                <span class="meta-tag">üî§ String</span>
                <span class="meta-tag">üîÑ Backtracking</span>
                <span class="meta-tag">‚è±Ô∏è O(2‚Åø)</span>
            </div>
            <div class="file-ref">
                üìÑ Python: <code>python/0017_letter_combinations_of_a_phone_number/0017_letter_combinations_of_a_phone_number.py</code>
            </div>

        </div>

        <div class="explanation-panel">
            <h4>üß† How It Works (Layman's Terms)</h4>
            <p>Backtracking <strong>explores all possibilities</strong> like solving a maze:</p>
            <ul>
                <li><strong>Choose:</strong> Make a decision</li>
                <li><strong>Explore:</strong> Recursively continue</li>
                <li><strong>Validate:</strong> Check if path is valid</li>
                <li><strong>Backtrack:</strong> Undo choice if stuck, try another</li>
            </ul>
        </div>


        <div class="visualization-section">
            <h3>üé¨ Step-by-Step Visualization</h3>

            <div class="visualization">
            <svg id="mainSvg"></svg>
        </div>

        <div class="controls">
            <button id="stepBtn">Step</button>
            <button id="autoBtn">Auto Run</button>
            <button id="resetBtn">Reset</button>
            <div class="speed-control">
                <label for="speed">Speed:</label>
                <input type="range" id="speed" min="100" max="2000" value="800">
            </div>
        </div>

        <div class="status" id="status">Click "Step" to generate combinations</div>

        <div class="variables">
            <div class="var-item">
                <span class="var-label">Input:</span>
                <span id="inputDisplay">"23"</span>
            </div>
            <div class="var-item">
                <span class="var-label">Current:</span>
                <span id="currentDisplay">""</span>
            </div>
            <div class="var-item">
                <span class="var-label">Results:</span>
                <span id="resultDisplay">[]</span>
            </div>
        </div>

        </div>

        <div class="code-section">
            <h3>Python Solution</h3>
            <pre><span class="keyword">def</span> <span class="function">letterCombinations</span>(digits):
    <span class="string">"""
    Backtracking to build all combinations.
    Time: O(4^n), Space: O(n)
    """</span>
    <span class="keyword">if</span> <span class="keyword">not</span> digits:
        <span class="keyword">return</span> []
    
    phone = {
        <span class="string">'2'</span>: <span class="string">'abc'</span>, <span class="string">'3'</span>: <span class="string">'def'</span>, <span class="string">'4'</span>: <span class="string">'ghi'</span>,
        <span class="string">'5'</span>: <span class="string">'jkl'</span>, <span class="string">'6'</span>: <span class="string">'mno'</span>, <span class="string">'7'</span>: <span class="string">'pqrs'</span>,
        <span class="string">'8'</span>: <span class="string">'tuv'</span>, <span class="string">'9'</span>: <span class="string">'wxyz'</span>
    }
    
    result = []
    
    <span class="keyword">def</span> <span class="function">backtrack</span>(idx, path):
        <span class="keyword">if</span> idx == <span class="function">len</span>(digits):
            result.<span class="function">append</span>(path)
            <span class="keyword">return</span>
        
        <span class="keyword">for</span> letter <span class="keyword">in</span> phone[digits[idx]]:
            <span class="function">backtrack</span>(idx + <span class="number">1</span>, path + letter)
    
    <span class="function">backtrack</span>(<span class="number">0</span>, <span class="string">""</span>)
    <span class="keyword">return</span> result</pre>
        </div>
    </div>

    <script>
        const digits = "23";
        const phone = {
            '2': 'abc', '3': 'def', '4': 'ghi',
            '5': 'jkl', '6': 'mno', '7': 'pqrs',
            '8': 'tuv', '9': 'wxyz'
        };

        let callStack = [{idx: 0, path: "", letterIdx: 0}];
        let results = [];
        let autoRunning = false;
        let autoTimer = null;

        const width = 750;
        const height = 450;
        const svg = d3.select("#mainSvg")
            .attr("width", width)
            .attr("height", height);

        function draw() {
            svg.selectAll("*").remove();

            svg.append("text")
                .attr("x", width / 2).attr("y", 25)
                .attr("text-anchor", "middle")
                .attr("font-weight", "bold")
                .text(`Phone Letter Combinations: "${digits}"`);

            // Draw phone keypad (simplified)
            const keypadX = 50;
            const keypadY = 60;
            const keyWidth = 60;
            const keyHeight = 45;

            const keys = [
                {digit: '2', letters: 'abc'},
                {digit: '3', letters: 'def'}
            ];

            keys.forEach((key, i) => {
                const x = keypadX + i * (keyWidth + 10);
                const isActive = callStack.length > 0 && 
                    callStack[callStack.length - 1].idx === i;

                svg.append("rect")
                    .attr("x", x).attr("y", keypadY)
                    .attr("width", keyWidth).attr("height", keyHeight)
                    .attr("rx", 8)
                    .attr("fill", isActive ? "#ffeb3b" : "#e3f2fd")
                    .attr("stroke", isActive ? "#f57c00" : "#1976d2")
                    .attr("stroke-width", 2);

                svg.append("text")
                    .attr("x", x + keyWidth / 2).attr("y", keypadY + 22)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "20px")
                    .attr("font-weight", "bold")
                    .text(key.digit);

                svg.append("text")
                    .attr("x", x + keyWidth / 2).attr("y", keypadY + 38)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "12px")
                    .attr("fill", "#666")
                    .text(key.letters);
            });

            // Draw decision tree
            const treeStartX = 400;
            const treeStartY = 50;

            // Root
            svg.append("circle")
                .attr("cx", treeStartX).attr("cy", treeStartY)
                .attr("r", 15)
                .attr("fill", "#e3f2fd").attr("stroke", "#1976d2");
            svg.append("text")
                .attr("x", treeStartX).attr("y", treeStartY + 5)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .text('""');

            // First level (digit 2: a, b, c)
            const letters2 = phone['2'].split('');
            const level1Y = 120;
            const level1Spread = 100;

            letters2.forEach((letter, i) => {
                const x = treeStartX - level1Spread + i * level1Spread;
                
                svg.append("line")
                    .attr("x1", treeStartX).attr("y1", treeStartY + 15)
                    .attr("x2", x).attr("y2", level1Y - 15)
                    .attr("stroke", "#ddd").attr("stroke-width", 2);

                const hasResult = results.some(r => r[0] === letter);
                const isBuilding = callStack.some(c => c.path === letter || c.path.startsWith(letter));

                svg.append("circle")
                    .attr("cx", x).attr("cy", level1Y)
                    .attr("r", 18)
                    .attr("fill", hasResult ? "#c8e6c9" : isBuilding ? "#fff3e0" : "#e3f2fd")
                    .attr("stroke", hasResult ? "#4caf50" : isBuilding ? "#ff9800" : "#1976d2");
                svg.append("text")
                    .attr("x", x).attr("y", level1Y + 5)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .attr("font-weight", "bold")
                    .text(letter);

                // Second level (digit 3: d, e, f)
                if (digits.length > 1) {
                    const letters3 = phone['3'].split('');
                    const level2Y = 190;
                    const level2Spread = 28;

                    letters3.forEach((letter2, j) => {
                        const x2 = x - level2Spread + j * level2Spread;
                        const combo = letter + letter2;
                        
                        svg.append("line")
                            .attr("x1", x).attr("y1", level1Y + 18)
                            .attr("x2", x2).attr("y2", level2Y - 15)
                            .attr("stroke", "#ddd").attr("stroke-width", 1);

                        const isResult = results.includes(combo);
                        const isCurrent = callStack.length > 0 && 
                            callStack[callStack.length - 1].path === combo;

                        svg.append("circle")
                            .attr("cx", x2).attr("cy", level2Y)
                            .attr("r", 16)
                            .attr("fill", isResult ? "#c8e6c9" : isCurrent ? "#ffeb3b" : "#f5f5f5")
                            .attr("stroke", isResult ? "#4caf50" : isCurrent ? "#f57c00" : "#bbb");
                        svg.append("text")
                            .attr("x", x2).attr("y", level2Y + 5)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "12px")
                            .attr("font-weight", isResult ? "bold" : "normal")
                            .text(combo);
                    });
                }
            });

            // Results
            svg.append("text")
                .attr("x", 50).attr("y", 280)
                .attr("font-weight", "bold")
                .text("Results:");

            results.forEach((result, i) => {
                const col = i % 5;
                const row = Math.floor(i / 5);
                
                svg.append("rect")
                    .attr("x", 120 + col * 55).attr("y", 265 + row * 35)
                    .attr("width", 50).attr("height", 28)
                    .attr("rx", 5)
                    .attr("fill", "#c8e6c9").attr("stroke", "#4caf50");
                svg.append("text")
                    .attr("x", 145 + col * 55).attr("y", 284 + row * 35)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .attr("font-weight", "bold")
                    .text(result);
            });

            // Current path
            if (callStack.length > 0) {
                const current = callStack[callStack.length - 1];
                svg.append("rect")
                    .attr("x", 50).attr("y", 350)
                    .attr("width", 150).attr("height", 35)
                    .attr("rx", 8)
                    .attr("fill", "#fff3e0").attr("stroke", "#ff9800");
                svg.append("text")
                    .attr("x", 125).attr("y", 373)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .text(`Building: "${current.path}"`);
            }
        }

        function step() {
            if (callStack.length === 0) {
                document.getElementById("status").textContent = 
                    `Done! Found ${results.length} combinations.`;
                draw();
                return false;
            }

            const {idx, path, letterIdx} = callStack.pop();

            if (idx === digits.length) {
                // Complete combination
                results.push(path);
                document.getElementById("resultDisplay").textContent = 
                    `[${results.map(r => `"${r}"`).join(', ')}]`;
                document.getElementById("status").textContent = 
                    `Complete! Added "${path}" to results.`;
            } else {
                const letters = phone[digits[idx]];
                
                if (letterIdx < letters.length) {
                    const letter = letters[letterIdx];
                    
                    // Push next letter choice for current digit
                    if (letterIdx + 1 < letters.length) {
                        callStack.push({idx, path, letterIdx: letterIdx + 1});
                    }
                    
                    // Push recursive call for next digit
                    callStack.push({idx: idx + 1, path: path + letter, letterIdx: 0});
                    
                    document.getElementById("currentDisplay").textContent = `"${path + letter}"`;
                    document.getElementById("status").textContent = 
                        `Digit ${digits[idx]}: trying letter "${letter}" ‚Üí path="${path + letter}"`;
                }
            }

            draw();
            return callStack.length > 0;
        }

        function reset() {
            callStack = [{idx: 0, path: "", letterIdx: 0}];
            results = [];
            autoRunning = false;
            if (autoTimer) clearInterval(autoTimer);
            
            document.getElementById("currentDisplay").textContent = '""';
            document.getElementById("resultDisplay").textContent = "[]";
            document.getElementById("status").textContent = 
                'Click "Step" to generate combinations';
            document.getElementById("autoBtn").textContent = "Auto Run";
            
            draw();
        }

        function autoRun() {
            if (autoRunning) {
                autoRunning = false;
                clearInterval(autoTimer);
                document.getElementById("autoBtn").textContent = "Auto Run";
            } else {
                autoRunning = true;
                document.getElementById("autoBtn").textContent = "Pause";
                const speed = 2100 - document.getElementById("speed").value;
                autoTimer = setInterval(() => {
                    if (!step()) {
                        autoRunning = false;
                        clearInterval(autoTimer);
                        document.getElementById("autoBtn").textContent = "Auto Run";
                    }
                }, speed);
            }
        }

        document.getElementById("stepBtn").addEventListener("click", step);
        document.getElementById("autoBtn").addEventListener("click", autoRun);
        document.getElementById("resetBtn").addEventListener("click", reset);

        draw();
    </script>
</body>
</html>
