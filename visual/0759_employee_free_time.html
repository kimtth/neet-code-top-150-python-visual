<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LC 759: Employee Free Time - Algorithm Visualization</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="problem-info">
            <h1><span class="problem-number">#759</span> Employee Free Time</h1>
            <p>Given schedules of multiple employees, find common free time intervals where all employees are available.</p>
            <div class="problem-meta">
                <span class="meta-tag">üìÖ Intervals</span>
                <span class="meta-tag">üî∫ Heap</span>
                <span class="meta-tag">‚è±Ô∏è O(n log n)</span>
                <span class="meta-tag">üíæ O(n)</span>
            </div>
            <div class="file-ref">
                üìÑ Python: <code>python/0759_employee_free_time/0759_employee_free_time.py</code>
            </div>
            </div>

        <div class="explanation-panel">
            <h4>üß† How It Works (Layman's Terms)</h4>
            <p>Merge all schedules and find gaps:</p>
            <ul>
                <li><strong>Step 1:</strong> Flatten all intervals from all employees</li>
                <li><strong>Step 2:</strong> Sort intervals by start time</li>
                <li><strong>Step 3:</strong> Merge overlapping intervals</li>
                <li><strong>Step 4:</strong> Find gaps between merged intervals = Free time!</li>
            </ul>
        </div>


        <div class="visualization-section">
            <h3>üé¨ Step-by-Step Visualization</h3>
            
            <div class="controls">
                <button class="btn btn-primary" id="startBtn" onclick="start()">‚ñ∂ Start</button>
                <button class="btn" onclick="stepForward()">Step ‚Üí</button>
                <button class="btn btn-warning" onclick="reset()">Reset</button>
            </div>

            <div class="status-message" id="statusMessage">
                Click Start to find common free time
            </div>

            <svg id="scheduleViz" width="100%" height="400"></svg>

            <div style="display: flex; gap: 20px; margin-top: 20px; flex-wrap: wrap;">
                <div style="flex: 1; min-width: 200px; padding: 15px; background: #e8f5e9; border-radius: 12px;">
                    <h4 style="margin: 0 0 10px 0; color: #2e7d32;">‚úÖ Free Time Slots</h4>
                    <div id="freeTimeDisplay" style="font-size: 16px;">Finding...</div>
                </div>
                <div style="flex: 1; min-width: 200px; padding: 15px; background: #fff3e0; border-radius: 12px;">
                    <h4 style="margin: 0 0 10px 0; color: #e65100;">üìä All Intervals</h4>
                    <div id="allIntervalsDisplay" style="font-size: 14px;">...</div>
                </div>
            </div>
        </div>

        <div class="code-section">
            <h3>üíª Python Solution</h3>
            <div class="code-block">
                <pre><span class="keyword">def</span> <span class="function">employeeFreeTime</span>(schedules):
    <span class="comment"># Flatten all intervals</span>
    intervals = []
    <span class="keyword">for</span> schedule <span class="keyword">in</span> schedules:
        <span class="keyword">for</span> interval <span class="keyword">in</span> schedule:
            intervals.<span class="function">append</span>([interval.start, interval.end])
    
    <span class="comment"># Sort by start time</span>
    intervals.<span class="function">sort</span>()
    
    <span class="comment"># Merge overlapping intervals</span>
    merged = [intervals[<span class="number">0</span>]]
    <span class="keyword">for</span> start, end <span class="keyword">in</span> intervals[<span class="number">1</span>:]:
        <span class="keyword">if</span> start <= merged[-<span class="number">1</span>][<span class="number">1</span>]:
            merged[-<span class="number">1</span>][<span class="number">1</span>] = <span class="function">max</span>(merged[-<span class="number">1</span>][<span class="number">1</span>], end)
        <span class="keyword">else</span>:
            merged.<span class="function">append</span>([start, end])
    
    <span class="comment"># Find gaps (free time)</span>
    result = []
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">1</span>, <span class="function">len</span>(merged)):
        result.<span class="function">append</span>([merged[i-<span class="number">1</span>][<span class="number">1</span>], merged[i][<span class="number">0</span>]])
    
    <span class="keyword">return</span> result</pre>
            </div>
        </div>
    </div>

    <script>
        // Employee schedules: list of (employee, intervals)
        const schedules = [
            { name: 'Alice', color: '#e91e63', intervals: [[1, 3], [6, 7]] },
            { name: 'Bob', color: '#2196f3', intervals: [[2, 4]] },
            { name: 'Carol', color: '#ff9800', intervals: [[2, 5], [9, 12]] }
        ];

        let stepIndex = 0;
        let steps = [];
        let isRunning = false;

        function precomputeSteps() {
            steps = [];
            
            // Step 0: Show original schedules
            steps.push({
                phase: 'original',
                message: 'Employee schedules shown. We need to find gaps where everyone is free.',
                highlight: null,
                merged: [],
                freeTimes: []
            });

            // Flatten and sort all intervals
            let allIntervals = [];
            schedules.forEach((emp, empIdx) => {
                emp.intervals.forEach(interval => {
                    allIntervals.push({ start: interval[0], end: interval[1], emp: empIdx });
                });
            });
            allIntervals.sort((a, b) => a.start - b.start);

            steps.push({
                phase: 'flatten',
                message: `All ${allIntervals.length} intervals collected and sorted by start time.`,
                highlight: 'all',
                allIntervals: allIntervals.map(i => [i.start, i.end]),
                merged: [],
                freeTimes: []
            });

            // Merge intervals one by one
            let merged = [];
            allIntervals.forEach((interval, idx) => {
                if (merged.length === 0 || interval.start > merged[merged.length - 1][1]) {
                    merged.push([interval.start, interval.end]);
                } else {
                    merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], interval.end);
                }
                
                steps.push({
                    phase: 'merge',
                    message: `Processing interval [${interval.start}, ${interval.end}]: ${merged.length === 1 && idx > 0 ? 'Extended previous' : merged.length > (steps[steps.length - 1]?.merged?.length || 0) ? 'Added new' : 'Extended merged'}`,
                    highlight: idx,
                    allIntervals: allIntervals.map(i => [i.start, i.end]),
                    merged: JSON.parse(JSON.stringify(merged)),
                    freeTimes: []
                });
            });

            // Find free times
            let freeTimes = [];
            for (let i = 1; i < merged.length; i++) {
                freeTimes.push([merged[i - 1][1], merged[i][0]]);
            }

            steps.push({
                phase: 'gaps',
                message: `Finding gaps between merged intervals...`,
                highlight: null,
                merged: merged,
                freeTimes: [],
                showGaps: true
            });

            steps.push({
                phase: 'result',
                message: `Found ${freeTimes.length} free time slot${freeTimes.length !== 1 ? 's' : ''}: ${freeTimes.map(f => `[${f[0]}, ${f[1]}]`).join(', ') || 'None'}`,
                highlight: null,
                merged: merged,
                freeTimes: freeTimes
            });
        }

        function render() {
            const svg = d3.select("#scheduleViz");
            svg.selectAll("*").remove();

            const container = svg.node().parentElement;
            const width = container.clientWidth;
            const height = 400;
            svg.attr("viewBox", `0 0 ${width} ${height}`);

            const margin = { left: 80, right: 40, top: 40, bottom: 80 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const step = stepIndex < steps.length ? steps[stepIndex] : steps[steps.length - 1] || {};

            // Time scale (0-14)
            const xScale = d3.scaleLinear().domain([0, 14]).range([0, chartWidth]);

            // Draw time axis
            const g = svg.append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);
            
            for (let t = 0; t <= 14; t++) {
                g.append("line")
                    .attr("x1", xScale(t)).attr("y1", 0)
                    .attr("x2", xScale(t)).attr("y2", chartHeight)
                    .attr("stroke", "#eee");
                
                g.append("text")
                    .attr("x", xScale(t)).attr("y", chartHeight + 20)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#666").attr("font-size", "12px")
                    .text(t);
            }

            const rowHeight = 50;
            const barHeight = 30;

            // Draw employee schedules
            schedules.forEach((emp, i) => {
                const y = i * rowHeight;
                
                g.append("text")
                    .attr("x", -10).attr("y", y + barHeight / 2 + 5)
                    .attr("text-anchor", "end")
                    .attr("fill", "#333").attr("font-size", "14px").attr("font-weight", "bold")
                    .text(emp.name);

                emp.intervals.forEach(interval => {
                    g.append("rect")
                        .attr("x", xScale(interval[0]))
                        .attr("y", y)
                        .attr("width", xScale(interval[1]) - xScale(interval[0]))
                        .attr("height", barHeight)
                        .attr("fill", emp.color)
                        .attr("opacity", 0.8)
                        .attr("rx", 4);
                    
                    g.append("text")
                        .attr("x", xScale((interval[0] + interval[1]) / 2))
                        .attr("y", y + barHeight / 2 + 5)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white").attr("font-size", "12px").attr("font-weight", "bold")
                        .text(`[${interval[0]},${interval[1]}]`);
                });
            });

            // Draw merged row
            const mergedY = schedules.length * rowHeight + 30;
            g.append("text")
                .attr("x", -10).attr("y", mergedY + barHeight / 2 + 5)
                .attr("text-anchor", "end")
                .attr("fill", "#333").attr("font-size", "14px").attr("font-weight", "bold")
                .text("Merged");

            if (step.merged) {
                step.merged.forEach(interval => {
                    g.append("rect")
                        .attr("x", xScale(interval[0]))
                        .attr("y", mergedY)
                        .attr("width", xScale(interval[1]) - xScale(interval[0]))
                        .attr("height", barHeight)
                        .attr("fill", "#667eea")
                        .attr("opacity", 0.9)
                        .attr("rx", 4);
                    
                    g.append("text")
                        .attr("x", xScale((interval[0] + interval[1]) / 2))
                        .attr("y", mergedY + barHeight / 2 + 5)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white").attr("font-size", "12px").attr("font-weight", "bold")
                        .text(`[${interval[0]},${interval[1]}]`);
                });
            }

            // Draw free time
            const freeY = mergedY + rowHeight + 10;
            g.append("text")
                .attr("x", -10).attr("y", freeY + barHeight / 2 + 5)
                .attr("text-anchor", "end")
                .attr("fill", "#2e7d32").attr("font-size", "14px").attr("font-weight", "bold")
                .text("Free");

            if (step.freeTimes && step.freeTimes.length > 0) {
                step.freeTimes.forEach(interval => {
                    g.append("rect")
                        .attr("x", xScale(interval[0]))
                        .attr("y", freeY)
                        .attr("width", xScale(interval[1]) - xScale(interval[0]))
                        .attr("height", barHeight)
                        .attr("fill", "#4caf50")
                        .attr("opacity", 0.9)
                        .attr("rx", 4);
                    
                    g.append("text")
                        .attr("x", xScale((interval[0] + interval[1]) / 2))
                        .attr("y", freeY + barHeight / 2 + 5)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white").attr("font-size", "12px").attr("font-weight", "bold")
                        .text(`[${interval[0]},${interval[1]}]`);
                });
            } else if (step.showGaps && step.merged && step.merged.length > 1) {
                // Show gap indicators
                for (let i = 1; i < step.merged.length; i++) {
                    const gapStart = step.merged[i - 1][1];
                    const gapEnd = step.merged[i][0];
                    
                    g.append("rect")
                        .attr("x", xScale(gapStart))
                        .attr("y", freeY)
                        .attr("width", xScale(gapEnd) - xScale(gapStart))
                        .attr("height", barHeight)
                        .attr("fill", "none")
                        .attr("stroke", "#4caf50")
                        .attr("stroke-width", 3)
                        .attr("stroke-dasharray", "5,3")
                        .attr("rx", 4);
                }
            }

            // Update displays
            document.getElementById('statusMessage').textContent = step.message || 'Ready';
            
            if (step.freeTimes && step.freeTimes.length > 0) {
                document.getElementById('freeTimeDisplay').innerHTML = step.freeTimes.map(f => 
                    `<div style="padding: 8px 12px; margin: 5px 0; background: #4caf50; color: white; border-radius: 6px; display: inline-block; margin-right: 5px;">
                        [${f[0]}, ${f[1]}]
                    </div>`
                ).join('');
            } else {
                document.getElementById('freeTimeDisplay').innerHTML = '<span style="color: #999;">Finding...</span>';
            }

            // All intervals display
            let allIntervals = [];
            schedules.forEach(emp => {
                emp.intervals.forEach(i => allIntervals.push([i[0], i[1]]));
            });
            allIntervals.sort((a, b) => a[0] - b[0]);
            document.getElementById('allIntervalsDisplay').textContent = allIntervals.map(i => `[${i[0]},${i[1]}]`).join(', ');
        }

        function stepForward() {
            if (stepIndex < steps.length - 1) {
                stepIndex++;
                render();
            }
        }

        async function start() {
            if (isRunning) {
                isRunning = false;
                document.getElementById('startBtn').textContent = '‚ñ∂ Start';
                return;
            }
            
            isRunning = true;
            document.getElementById('startBtn').textContent = '‚è∏ Pause';
            
            while (stepIndex < steps.length - 1 && isRunning) {
                stepForward();
                await new Promise(r => setTimeout(r, 1200));
            }
            
            isRunning = false;
            document.getElementById('startBtn').textContent = '‚ñ∂ Start';
        }

        function reset() {
            isRunning = false;
            stepIndex = 0;
            document.getElementById('startBtn').textContent = '‚ñ∂ Start';
            precomputeSteps();
            render();
        }

        reset();
        window.addEventListener('resize', render);
    </script>
</body>
</html>
