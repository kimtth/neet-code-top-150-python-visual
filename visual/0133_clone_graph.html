<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clone Graph - Algorithm Visualization</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    </div>

    <div class="container">
        <div class="problem-info">
            <h1><span class="problem-number">#0133</span> Clone Graph</h1>
            <p>
                Given a reference of a node in a connected undirected graph, return a <strong>deep copy (clone)</strong> of the graph.
                Each node contains a value and a list of its neighbors.
            </p>
            <p><strong>Example:</strong> adjList = [[2,4],[1,3],[2,4],[1,3]] ‚Üí Clone with same structure</p>
            <p><strong>Approach:</strong> DFS/BFS with hashmap to track original ‚Üí clone mapping</p>
            <p><strong>Time Complexity:</strong> O(V + E) | <strong>Space Complexity:</strong> O(V)</p>
            <div class="problem-meta">
                <span class="meta-tag">üîó Graph</span>
                <span class="meta-tag">‚è±Ô∏è O(m√ón)</span>
            </div>
            <div class="file-ref">
                üìÑ Python: <code>python/0133_clone_graph/0133_clone_graph.py</code>
            </div>

        </div>

        <div class="explanation-panel">
            <h4>üß† How It Works (Layman's Terms)</h4>
            <p>Graph problems are like <strong>exploring a maze</strong>:</p>
            <ul>
                <li><strong>Nodes:</strong> Points or locations</li>
                <li><strong>Edges:</strong> Connections between nodes</li>
                <li><strong>Traverse:</strong> Use DFS or BFS to explore</li>
                <li><strong>Track visited:</strong> Avoid infinite loops</li>
            </ul>
        </div>


        <div class="visualization-section">
            <h3>üé¨ Step-by-Step Visualization</h3>
            <div class="controls">
                <button id="stepBtn" class="btn">Step</button>
                <button id="autoBtn" class="btn">Auto Run</button>
                <button id="resetBtn" class="btn btn-secondary">Reset</button>
                <div class="speed-control">
                    <label for="speedSlider">Speed:</label>
                    <input type="range" id="speedSlider" min="1" max="10" value="5">
                </div>
            </div>
            <svg id="visualization" width="900" height="500"></svg>
            <div class="variables-display">
                <div id="varDisplay"></div>
            </div>
            <div class="status-message" id="statusMessage">Press "Step" or "Auto Run" to begin</div>
        </div>

        <div class="code-section">
            <h3>üíª Python Solution</h3>
            <div class="code-block">
                <pre><span class="keyword">def</span> <span class="function">cloneGraph</span>(self, node: <span class="class-name">Node</span>) -> Node:
    <span class="keyword">if</span> <span class="keyword">not</span> node:
        <span class="keyword">return</span> <span class="keyword">None</span>
    
    clones = {}  <span class="comment"># Map original -> clone</span>
    
    <span class="keyword">def</span> <span class="function">dfs</span>(original: <span class="class-name">Node</span>) -> Node:
        <span class="keyword">if</span> original <span class="keyword">in</span> clones:
            <span class="keyword">return</span> clones[original]
        
        <span class="comment"># Create clone</span>
        clone = <span class="function">Node</span>(original.val)
        clones[original] = clone
        
        <span class="comment"># Clone neighbors</span>
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> original.neighbors:
            clone.neighbors.<span class="function">append</span>(<span class="function">dfs</span>(neighbor))
        
        <span class="keyword">return</span> clone
    
    <span class="keyword">return</span> <span class="function">dfs</span>(node)</pre>
            </div>
        </div>
    </div>

    <script>
        // Graph: [[2,4],[1,3],[2,4],[1,3]] - Square graph
        // Node 1 connects to 2, 4
        // Node 2 connects to 1, 3
        // Node 3 connects to 2, 4
        // Node 4 connects to 1, 3
        
        const originalPositions = {
            1: { x: 120, y: 120 },
            2: { x: 280, y: 120 },
            3: { x: 280, y: 280 },
            4: { x: 120, y: 280 }
        };
        
        const clonePositions = {
            1: { x: 520, y: 120 },
            2: { x: 680, y: 120 },
            3: { x: 680, y: 280 },
            4: { x: 520, y: 280 }
        };
        
        const edges = [[1, 2], [2, 3], [3, 4], [4, 1]];
        
        // State
        let step = 0;
        let autoRunning = false;
        let autoInterval = null;
        
        // Generate steps
        const steps = [];
        
        function generateSteps() {
            steps.length = 0;
            
            steps.push({
                type: 'init',
                cloned: [],
                processing: null,
                cloneMap: {},
                message: 'Original graph with 4 nodes. Clone using DFS + hashmap.'
            });
            
            steps.push({
                type: 'start',
                cloned: [],
                processing: 1,
                cloneMap: {},
                message: 'Start DFS from node 1. Create clone of node 1.'
            });
            
            steps.push({
                type: 'clone',
                cloned: [1],
                processing: 1,
                cloneMap: { 1: "1'" },
                message: 'Clone node 1 created. Add to hashmap: {1 ‚Üí 1\'}. Visit neighbors.'
            });
            
            steps.push({
                type: 'visit_neighbor',
                cloned: [1],
                processing: 2,
                cloneMap: { 1: "1'" },
                parent: 1,
                message: 'Visit neighbor 2 of node 1. Node 2 not cloned yet.'
            });
            
            steps.push({
                type: 'clone',
                cloned: [1, 2],
                processing: 2,
                cloneMap: { 1: "1'", 2: "2'" },
                message: 'Clone node 2 created. Add to hashmap. Visit neighbors of 2.'
            });
            
            steps.push({
                type: 'visit_neighbor',
                cloned: [1, 2],
                processing: 1,
                cloneMap: { 1: "1'", 2: "2'" },
                parent: 2,
                alreadyCloned: true,
                message: 'Neighbor 1 of node 2 already cloned. Return existing clone.'
            });
            
            steps.push({
                type: 'visit_neighbor',
                cloned: [1, 2],
                processing: 3,
                cloneMap: { 1: "1'", 2: "2'" },
                parent: 2,
                message: 'Visit neighbor 3 of node 2. Node 3 not cloned yet.'
            });
            
            steps.push({
                type: 'clone',
                cloned: [1, 2, 3],
                processing: 3,
                cloneMap: { 1: "1'", 2: "2'", 3: "3'" },
                message: 'Clone node 3 created. Add to hashmap. Visit neighbors of 3.'
            });
            
            steps.push({
                type: 'visit_neighbor',
                cloned: [1, 2, 3],
                processing: 2,
                cloneMap: { 1: "1'", 2: "2'", 3: "3'" },
                parent: 3,
                alreadyCloned: true,
                message: 'Neighbor 2 of node 3 already cloned. Return existing clone.'
            });
            
            steps.push({
                type: 'visit_neighbor',
                cloned: [1, 2, 3],
                processing: 4,
                cloneMap: { 1: "1'", 2: "2'", 3: "3'" },
                parent: 3,
                message: 'Visit neighbor 4 of node 3. Node 4 not cloned yet.'
            });
            
            steps.push({
                type: 'clone',
                cloned: [1, 2, 3, 4],
                processing: 4,
                cloneMap: { 1: "1'", 2: "2'", 3: "3'", 4: "4'" },
                message: 'Clone node 4 created. All nodes cloned!'
            });
            
            steps.push({
                type: 'connect',
                cloned: [1, 2, 3, 4],
                processing: null,
                cloneMap: { 1: "1'", 2: "2'", 3: "3'", 4: "4'" },
                connecting: true,
                message: 'Connect all cloned nodes according to original edges.'
            });
            
            steps.push({
                type: 'done',
                cloned: [1, 2, 3, 4],
                processing: null,
                cloneMap: { 1: "1'", 2: "2'", 3: "3'", 4: "4'" },
                complete: true,
                message: 'Done! Graph cloned successfully. Both graphs are independent copies.'
            });
        }
        
        // SVG setup
        const svg = d3.select("#visualization");
        const width = 900;
        const height = 500;
        
        function draw(currentStep) {
            svg.selectAll("*").remove();
            
            const data = currentStep || steps[0];
            
            // Draw arrow marker
            svg.append("defs").append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 0 10 10")
                .attr("refX", 5)
                .attr("refY", 5)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M 0 0 L 10 5 L 0 10 z")
                .attr("fill", "#f59e0b");
            
            // Labels
            svg.append("text")
                .attr("x", 200)
                .attr("y", 40)
                .attr("text-anchor", "middle")
                .attr("class", "label")
                .text("Original Graph");
            
            svg.append("text")
                .attr("x", 600)
                .attr("y", 40)
                .attr("text-anchor", "middle")
                .attr("class", "label")
                .text("Cloned Graph");
            
            // Draw original graph edges
            edges.forEach(([from, to]) => {
                const x1 = originalPositions[from].x;
                const y1 = originalPositions[from].y;
                const x2 = originalPositions[to].x;
                const y2 = originalPositions[to].y;
                
                svg.append("line")
                    .attr("x1", x1)
                    .attr("y1", y1)
                    .attr("x2", x2)
                    .attr("y2", y2)
                    .attr("stroke", "#667eea")
                    .attr("stroke-width", 2);
            });
            
            // Draw original graph nodes
            [1, 2, 3, 4].forEach(val => {
                const pos = originalPositions[val];
                
                let fill = "#667eea";
                let stroke = "none";
                let strokeWidth = 0;
                
                if (data.processing === val && !data.alreadyCloned) {
                    fill = "#f59e0b";
                    stroke = "#d97706";
                    strokeWidth = 3;
                } else if (data.cloned && data.cloned.includes(val)) {
                    fill = "#4ade80";
                }
                
                svg.append("circle")
                    .attr("cx", pos.x)
                    .attr("cy", pos.y)
                    .attr("r", 28)
                    .attr("fill", fill)
                    .attr("stroke", stroke)
                    .attr("stroke-width", strokeWidth);
                
                svg.append("text")
                    .attr("x", pos.x)
                    .attr("y", pos.y + 6)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .attr("font-weight", "bold")
                    .attr("font-size", "18px")
                    .text(val);
            });
            
            // Draw clone edges
            if (data.connecting || data.complete) {
                edges.forEach(([from, to]) => {
                    const x1 = clonePositions[from].x;
                    const y1 = clonePositions[from].y;
                    const x2 = clonePositions[to].x;
                    const y2 = clonePositions[to].y;
                    
                    svg.append("line")
                        .attr("x1", x1)
                        .attr("y1", y1)
                        .attr("x2", x2)
                        .attr("y2", y2)
                        .attr("stroke", "#4ade80")
                        .attr("stroke-width", 2);
                });
            }
            
            // Draw cloned nodes
            if (data.cloned && data.cloned.length > 0) {
                data.cloned.forEach(val => {
                    const pos = clonePositions[val];
                    
                    const isNew = data.processing === val && data.type === 'clone';
                    
                    svg.append("circle")
                        .attr("cx", pos.x)
                        .attr("cy", pos.y)
                        .attr("r", 28)
                        .attr("fill", "#4ade80")
                        .attr("stroke", isNew ? "#16a34a" : "none")
                        .attr("stroke-width", isNew ? 4 : 0);
                    
                    svg.append("text")
                        .attr("x", pos.x)
                        .attr("y", pos.y + 6)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .attr("font-weight", "bold")
                        .attr("font-size", "16px")
                        .text(val + "'");
                });
            }
            
            // Draw mapping arrows
            if (data.cloned && data.cloned.length > 0 && data.type !== 'init') {
                data.cloned.forEach(val => {
                    const orig = originalPositions[val];
                    const clone = clonePositions[val];
                    
                    svg.append("path")
                        .attr("d", `M ${orig.x + 35} ${orig.y} Q ${(orig.x + clone.x) / 2} ${orig.y - 30} ${clone.x - 35} ${clone.y}`)
                        .attr("fill", "none")
                        .attr("stroke", "#f59e0b")
                        .attr("stroke-width", 2)
                        .attr("stroke-dasharray", "5,5")
                        .attr("marker-end", "url(#arrow)");
                });
            }
            
            // Draw hashmap
            svg.append("text")
                .attr("x", 400)
                .attr("y", 380)
                .attr("text-anchor", "middle")
                .attr("class", "label")
                .text("Clone Map (HashMap):");
            
            if (data.cloneMap && Object.keys(data.cloneMap).length > 0) {
                const entries = Object.entries(data.cloneMap);
                entries.forEach(([key, value], i) => {
                    const x = 280 + i * 70;
                    
                    svg.append("rect")
                        .attr("x", x)
                        .attr("y", 395)
                        .attr("width", 60)
                        .attr("height", 30)
                        .attr("rx", 6)
                        .attr("fill", "#fef3c7")
                        .attr("stroke", "#f59e0b");
                    
                    svg.append("text")
                        .attr("x", x + 30)
                        .attr("y", 415)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "12px")
                        .text(`${key}‚Üí${value}`);
                });
            } else {
                svg.append("text")
                    .attr("x", 400)
                    .attr("y", 415)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#9ca3af")
                    .text("{ }");
            }
            
            // Legend
            const legendY = 460;
            svg.append("circle").attr("cx", 150).attr("cy", legendY).attr("r", 10).attr("fill", "#667eea");
            svg.append("text").attr("x", 165).attr("y", legendY + 4).attr("fill", "#4b5563").text("Original");
            
            svg.append("circle").attr("cx", 280).attr("cy", legendY).attr("r", 10).attr("fill", "#f59e0b");
            svg.append("text").attr("x", 295).attr("y", legendY + 4).attr("fill", "#4b5563").text("Processing");
            
            svg.append("circle").attr("cx", 420).attr("cy", legendY).attr("r", 10).attr("fill", "#4ade80");
            svg.append("text").attr("x", 435).attr("y", legendY + 4).attr("fill", "#4b5563").text("Cloned");
            
            // Update status
            document.getElementById("statusMessage").textContent = data.message;
            
            // Update variables
            document.getElementById("varDisplay").innerHTML = `
                <span class="var-item">Processing: ${data.processing || 'None'}</span>
                <span class="var-item">Cloned: [${data.cloned ? data.cloned.join(', ') : ''}]</span>
                <span class="var-item">Map Size: ${data.cloneMap ? Object.keys(data.cloneMap).length : 0}</span>
            `;
        }
        
        function doStep() {
            if (step >= steps.length) {
                stopAuto();
                return;
            }
            draw(steps[step]);
            step++;
        }
        
        function stopAuto() {
            autoRunning = false;
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
            }
            document.getElementById("autoBtn").textContent = "Auto Run";
        }
        
        function toggleAuto() {
            if (autoRunning) {
                stopAuto();
            } else {
                autoRunning = true;
                document.getElementById("autoBtn").textContent = "Pause";
                const speed = 11 - document.getElementById("speedSlider").value;
                autoInterval = setInterval(() => {
                    if (step >= steps.length) {
                        stopAuto();
                        return;
                    }
                    doStep();
                }, speed * 200);
            }
        }
        
        function reset() {
            stopAuto();
            step = 0;
            draw(steps[0]);
        }
        
        // Initialize
        generateSteps();
        draw(steps[0]);
        
        // Event listeners
        document.getElementById("stepBtn").addEventListener("click", doStep);
        document.getElementById("autoBtn").addEventListener("click", toggleAuto);
        document.getElementById("resetBtn").addEventListener("click", reset);
    </script>
</body>
</html>
